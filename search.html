<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
<title>Search</title>
<style type="text/css">
<!--
/* begin css/default.css */
.tag-flag,
.tag-troll,
.tag-spam,
.tag-remove,
.tag-abuse {
/* negative (red) tags */
	color: #c00000;
}

.tag-remove {
/* remove tag */
	font-weight: bold;
}

.tag-approve,
.tag-accept,
.tag-friend,
.tag-attend {
/* positive (green) tags */
	color: #008000;
}

div.reply {
/* creates indented effect for sub-replies */
	margin-left: 2%;
	padding-left: 3em;
}

.item-textart {
/* textart items get monospace font */
	font-family: monospace;
	font-size: 12pt;
}

.tag-aolart {
/* aol art in 10-point arial font */
    font-family: Arial;
    font-size: 10pt;
}

div.txt {
	padding-left: 1em;
}

.byadmin {
/* text by admin, displayed in red for users' sake */
	color: red;
}

.signed {
/* signed things are displayed in gold */
    border-color: gold;
}


#eventLocation, #eventBrcLocation {
/* event form */
	background-color: #ffffff;
	padding: 5pt;
}

#eventDate {
/* event form */
	background-color: #e0e0e0;
	padding: 5pt;
}

#loadingIndicator, #spanLoadingIndicator, #ariaAlert {
	color: #000000;
	background-color: #f0f0d0;
	padding: 3pt;
	position: fixed;
	top: 0;
	left: 0;
	margin: 0;
	font-family: tahoma, arial, sans-serif;
	font-size: smaller;
	font-weight: bold;
}
#loadingIndicator a {
	/* style for links in loading indicator */
}
.notification {
	color: #000000;
	background-color: #f0f0d0;
	padding: 3pt;
	font-size: smaller;
	font-weight: bold;
}
noscript {
	color: red;
}
.menubar a, .titlebar a {
	text-decoration: none;
	color: #000000;
}
/* end css/default.css */

/* avatar.css */
.avatar .icon {
	font-weight: bold;
	font-size: smaller;
}
/* / avatar.css */

/* dragging.css */

table.dialog {
	display: inline-block;
	vertical-align: top;
}
form {
	display: inline;
}

/* / dragging.css */

/* theme/mitbtc/additional.css */
/* / theme/mitbtc/additional.css */
/* theme/chicago/additional.css */
body {
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	background-color: #008080;
}
input {
	border-color: blue;
}
input[type=text], input[type=password], select, option, textarea {
	background-color: #ffffff;
	color: #000000;
}
#txtClock {
	border: 1pt inset #c0c0c0;
}
@media (prefers-color-scheme: dark) {

}
.beginner {
    background-color: #f0f0d0;
}
.dialog {
	box-shadow: 3pt 3pt 0 rgba(0, 20, 20, 0.5);
	border: #c0c0c0 outset 2pt;
	background-color: #c0c0c0;
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	font-size: 10pt;
}
.statusbar td {
	border: 1pt inset #c0c0c0;
}
textarea {
    font-family: Fixedsys, "Courier New", Courier, monospace;
    font-size: 12pt;
}

.txt {
/* regular text */
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	font-size: 14pt;
	background-color: #d0d2d4;
	border: 1pt #ffffff inset;
}

a:focus, a:active {
    color: red !important;
    background-color: orange !important;
}
textarea:focus {
    background-color: #fff0e0;
}
input:focus {
    background-color: orange;
}
#serverResponse {
/* response messages from the server */
    background-color: #ffc080;
    color: #000000;
    padding: 5pt;
    spacing: 5pt;
    border: 0;
	box-shadow: 5pt 5pt 0 rgba(0, 20, 20, 0.5);
}
#txtClock {
	border: 1pt inset #c0c0c0;
	background-color: #c0c0c0;
}
/* / theme/chicago/additional.css */
-->
</style>
</head>
<body background="/triangles.gif" onbeforeunload="if (window.ShowPreNavigateNotification){ ShowPreNavigateNotification();}" >
<!-- InjectJs2: loading_begin -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin loading_begin.js

//var loadingIndicatorWaitToShowMin = 1500;
//var loadingIndicatorWaitToHideMin = 500;

function addLoadingIndicator (strMessage) { // adds loading indicator bar (to top of page, depending on style)
	//alert('DEBUG: addLoadingIndicator(' + strMessage + ')');
	if (!strMessage) {
		//alert('DEBUG: strMessage = ' + strMessage);
		strMessage = 'Meditate...';
	}
	//alert('DEBUG: addLoadingIndicator: strMessage = ' + strMessage);

	if (!document.createElement) {
		//alert('DEBUG: addLoadingIndicator: warning: no document.createElement');
		return '';
		// #todo improve compatibility here
	}

	//alert('DEBUG: addLoadingIndicator: sanity checks passed!');
	var spanLoadingIndicator = document.createElement('span');
	if (spanLoadingIndicator) {
		spanLoadingIndicator.setAttribute('id', 'loadingIndicator');
		spanLoadingIndicator.innerHTML = strMessage;
		spanLoadingIndicator.zIndex = 1337;
		document.body.appendChild(spanLoadingIndicator);
	}

	return '';

} // addLoadingIndicator()

if (document.createElement) {
	//alert('DEBUG: loading_begin.js: createElement feature check PASSED!');
	var d = new Date();
	var loadingIndicatorStart = d.getTime() * 1;
	var gt = unescape('%3E');

	//var loadingIndicatorloadCounter = 0;
	addLoadingIndicator('Meditate...');
} else {
	//alert('DEBUG: loading_begin.js: createElement feature check FAILED!');
}
// end loading_begin.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->

<b><!-- mitbtc/template/topmenu2.template -->
<table cellspacing=0 cellpadding=3 border=0 bgcolor="#c0c0c0" class=dialog>
	<tr bgcolor="#35163A">
		<td colspan=2>
			<img alt="MIT Bitcoin Expo" title="MIT Bitcoin Expo" logo src="/logo.gif" height=16 width=16>
			<font color="#ffffff"><b>MIT Bitcoin Expo 2021</b></font>
			<a href="/etc.html" onclick="if (window.ShowAll) { ShowAll(this); } if (window.DraggingInit) { DraggingInit(0); } return false;" >.</a>
			<br>
		</td>
	</tr>
	<tr bgcolor="#c0c0c0" class=menubar>
		<td>
			<big>
				<big><!-- menuitem.template -->
<a accesskey="h" href="/"><u>H</u>ome</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="r" href="https://tinyurl.com/4ezdhdk"><u>R</u>egister</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="s" href="/speakers.html"><u>S</u>peakers</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="p" href="/sponsors.html">S<u>p</u>onsors</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="m" href="/media.html"><u>M</u>edia Partners</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="a" href="/academic.html"><u>A</u>cademic Partners</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="g" href="/agenda.html">A<u>g</u>enda</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="c" href="https://mit-bitcoin-expo-hackathon.devfolio.co/">Ha<u>c</u>kathon</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="o" href="/committee.html">C<u>o</u>mmittee</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="l" href="/links.html"><u>L</u>inks</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="i" href="https://eepurl.com/gOVdKb">Ma<u>i</u>ling List</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="e" href="/flashback_2020/">Prior <u>E</u>xpo</a>
<!-- / menuitem.template -->
 &nbsp; </big>
			</big>
		</td>
	</tr>
</table>
<!-- / mitbtc/template/topmenu2.template -->
</b>
<p><MAIN ID=maincontent><A NAME=maincontent></A>
<!-- window/standard.template -->
<font face=arial>
	<table cellspacing=0 cellpadding=6 border=0 bgcolor="#c0c0c0" class=dialog>
		<!-- titlebar_with_button.template -->
<tr bgcolor="#35163A" class=titlebar>
	<td valign=middle>
		<img alt="[-]" title="Window Icon" logo src="/logo.gif" height=16 width=16>
		<font color="#ffffff"><b>Public Search</b></font>
		<br>
	</td>
</tr>
<!-- / titlebar_with_button.template -->


		

		

		<tr class=content><td><!-- search.template -->
<p class=warning>
    <b>Your search will become public immediately.</b>
</p>
<form action="/post.html" name=search class=advanced>
    <p class=beginner>
        Put some text and press button.
    </p>
    <p>
        <input name=comment id=q type=text size=40>
        <input type=submit name=tag value="#Search">
    </p>
</form>
<!-- / search.template -->
</td></tr>

		
	</table>
</font>
<!-- / window/standard.template -->
<a name=35f00706></a></main>
<hr>
<img src="/p.gif" alt="" height=1 width=1>
<!-- back_to_top_button.template -->
<a
    href="#"
    onclick="if (window.scrollTo) { window.scrollTo(0, 0); return false; }"
    title="Back to top"
    id=aBackToTop
    style="
        position: fixed;
        right: 5pt;
        bottom: 5pt;
        background-color: #f0f0d0;
        border: 5pt;
        padding: 5pt;
        border-radius: 5pt;
        text-decoration: none;
    "
>^^</span></a>
<!-- / back_to_top_button.template -->
<!-- InjectJs: settings avatar profile puzzle fresh -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// == begin settings.js

var showAdvancedLastAction = '';
var showBeginnerLastAction = '';
var showMeaniesLastAction = '';
var showAdminLastAction = '';
var showTimestampsLastAction = '';

var timerShowAdvanced;

function SetElementVisible (element, displayValue, bgColor, borderStyle) { // sets element's visible status based on tag type
// displayValue = 'none' or 'initial'
// 	when 'initial', will try to substitute appropriate default for tag type
// also sets background color
// used for hiding/showing and highlighting beginner, advanced element classes on page.

    //alert ('DEBUG: \nelement:' + element + "\ndisplayValue:" + displayValue + "\nbgColor:" + bgColor + "\nborderStyle:" + borderStyle + "\n");

	if (bgColor) {
		// background color
		if (bgColor == 'initial') {
			bgColor = '#c0c0c0';
		}
		element.style.backgroundColor = bgColor;
		// this may cause issues in some themes
	}

	// depending on element type, we set different display style
	// block, table-row, table-cell, or default of 'initial'
	if (displayValue == 'initial' && (element.nodeName == 'P' || element.nodeName == 'H3' || element.nodeName == 'FIELDSET' || element.nodeName == 'HR')) {
		element.style.display = 'block';
	} else if (displayValue == 'initial' && element.nodeName == 'TR') {
		element.style.display = 'table-row';
	} else if (displayValue == 'initial' && (element.nodeName == 'TH' || element.nodeName == 'TD')) {
		if (element.innerHTML != '') {
			element.style.display = 'table-cell';
		} else {
			element.style.display = 'none'; // empty table cells display = none #why?
		}
	} else {
		if (displayValue == 'initial') {
			displayValue = 'inline';
		}
		element.style.display = displayValue;
		if (borderStyle) {
			// border style
			element.style.border = borderStyle;
			//element.style.borderRadius = '3pt';
		}
	}

	return 1;
} // SetElementVisible()

function ShowAll (t, container) { // t = clicked link ; container = document by default ; shows all elements, overriding settings
// admin elements are excluded. only beginner, advanced class elements are shown
	var gt = unescape('%3E');

	if (!container) {
		container = document;
	}

	var isMore = 1;
	if (t.innerHTML == 'Less') {
		// when without accesskey
		t.innerHTML = 'More';
		isMore = 0;
	}
	if (t.innerHTML == 'Less (<u' + gt + 'O</u' + gt + ')') {
		// when with accesskey
		t.innerHTML = 'M<u' + gt + 'o</u' + gt + 're';
		isMore = 0;
	}

    if (isMore && container.getElementsByClassName) {
		if (t.innerHTML == 'More') {
			// without accesskey
			t.innerHTML = 'Less';
		}
		if (t.innerHTML == 'M<u' + gt + 'o</u' + gt + 're') {
			// with accesskey
			t.innerHTML = 'Less (<u' + gt + 'O</u' + gt + ')';
		}

        var display;
        display = 'initial';

        var elements = container.getElementsByClassName('advanced');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], display, '#ffe0e0', 0);
        }
        elements = container.getElementsByClassName('beginner');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], display, '#f0f0d0', 0);
        }
        elements = container.getElementsByClassName('expand');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], 'none', '', 0);
        }

        if (timerShowAdvanced) {
            clearTimeout(timerShowAdvanced);
        }
		//timerShowAdvanced = setTimeout('ShowAdvanced(1);', 10000);
		//
		//if (t && t.getAttribute('onclick')) {
		//t.setAttribute('onclick', '');
		//}
		//if (window.ArrangeAll) {
		//	ArrangeAll();
		//}

        return false;
    } else {
    	ShowAdvanced(1);

    	return false;
	}

    return true;
} // ShowAll()

function ShowAdvanced (force, container) { // show or hide controls based on preferences
//handles class=advanced based on 'show_advanced' preference
//handles class=beginner based on 'beginner' preference
//force parameter
// 1 = does not re-do setTimeout (called this way from checkboxes)
// 0 = previous preference values are remembered, and are not re-done (called by timer)

	//alert('DEBUG: ShowAdvanced(' + force + ')');

	if (!container) {
		container = document;
	}

	if (document.getElementById && window.localStorage && container.getElementsByClassName) {
		//alert('DEBUG: ShowAdvanced: feature check passed!');
		///////////

		var displayTimestamps = '0';
		if (GetPrefs('expert_timestamps')) {
			displayTimestamps = 1;
		}
		if (force || window.showTimestampsLastAction != displayTimestamps) {
			//ShowTimestamps();
			window.showTimestampsLastAction = displayTimestamps;
		}

		var displayAdmin = 'none'; // not voting by default
		if (GetPrefs('show_admin') == 1) { // check value of show_admin preference
			displayAdmin = 'initial'; // display
		}
		if (force || showAdminLastAction != displayAdmin) {
			var elemAdmin = container.getElementsByClassName('admin');

			for (var i = 0; i < elemAdmin.length; i++) {
				SetElementVisible(elemAdmin[i], displayAdmin, 0, 0);
			}
		}

		var displayValue = 'none'; // hide by default
		if (GetPrefs('show_advanced') == 1) { // check value of show_advanced preference
			displayValue = 'initial'; // display
		}

		var bgColor = 'initial';
		if (GetPrefs('advanced_highlight') == 1) { // check value of advanced_highlight preference
			bgColor = '#ffe0e0'; // advanced_highlight
		}

		if (force || showAdvancedLastAction != (displayValue + bgColor)) {
			// thank you stackoverflow
			var divsToHide = container.getElementsByClassName("advanced"); //divsToHide is an array #todo nn3 compat
			for (var i = 0; i < divsToHide.length; i++) {
				//divsToHide[i].style.visibility = "hidden"; // or
				SetElementVisible(divsToHide[i], displayValue, bgColor, 0);
			}
//			var clock = document.getElementById('txtClock');
//			if (clock) {
//			    SetElementVisible(clock, displayValue, bgColor, 0);
//			}
			showAdvancedLastAction = displayValue + bgColor;
		}

		displayValue = 'initial'; // show by default
		if (GetPrefs('beginner') == 0) { // check value of beginner preference
			displayValue = 'none';
		}

		bgColor = 'initial';
		if (GetPrefs('beginner_highlight') == 1) { // check value of beginner preference
			bgColor = '#f0f0d0'; // beginner_highlight
		}

		if (force || showBeginnerLastAction != displayValue + bgColor) {
			var divsToShow = container.getElementsByClassName('beginner');//#todo nn3 compat

			for (var i = 0; i < divsToShow.length; i++) {
				SetElementVisible(divsToShow[i], displayValue, bgColor, 0);
			}
			showBeginnerLastAction = displayValue + bgColor;
		}
//
//		if (window.freshTimeoutId) {
//			// reset the page change notifier state
//			clearTimeout(window.freshTimeoutId);
//
//			if (GetPrefs('notify_on_change')) {
//				// check if page has changed, notify user if so
//				if (window.EventLoop) {
//					EventLoop();
//				}
//			}
//		}

		if (window.setAva) {
			setAva(); // #todo caching similar to above
		}

		//if (!force) {
			//if (timerShowAdvanced) {
			//	clearTimeout(timerShowAdvanced);
			//}
			//timerShowAdvanced = setTimeout('ShowAdvanced()', 3000);
		//}

		//SettingsOnload();

	} else {
		//alert('DEBUG: ShowAdvanced: feature check FAILED!');
		//alert('DEBUG: window.localStorage: ' + window.localStorage + '; document.getElementsByClassName: ' + document.getElementsByClassName);
	}

	//alert('DEBUG: ShowAdvanced: returning false');
	return false;
} // ShowAdvanced()

function GetPrefs (prefKey) { // get prefs value from localstorage
	// GetConfig {
	// GetSetting {
	//alert('debug: GetPrefs(' + prefKey + ')');
	if (window.localStorage) {
		var nameContainer = 'settings';
		{ // settings beginning with gtgt go into separate container
			var gt = unescape('%3E');
			if (prefKey.substr(0, 2) == gt+gt) {
				nameContainer = 'voted';
			}
		}
		var currentPrefs = localStorage.getItem(nameContainer);

		var prefsObj;
		if (currentPrefs) {
			prefsObj = JSON.parse(currentPrefs);
		} else {
			prefsObj = Object();
		}
		var prefValue = prefsObj[prefKey];

		if (!prefValue && prefValue != 0) {
			// these settings default to 1/true:
			if (
				prefKey == 'beginner' ||
				prefKey == 'beginner_highlight' ||
				prefKey == 'notify_on_change'
			) {
				prefValue = 1;
			}
			if (
				prefKey == 'show_advanced' ||
				prefKey == 'show_admin' ||
				prefKey == 'draggable'
			) {
				prefValue = 0;
			}
		}

		SetPrefs(prefKey, prefValue);

		return prefValue;
	}

	//alert('debug: GetPrefs: fallthrough, returning false');
	return false;
} // GetPrefs()

function SetPrefs (prefKey, prefValue) { // set prefs key prefKey to value prefValue
    //alert('DEBUG: SetPrefs(' + prefKey + ', ' + prefValue + ')');

	if (prefKey == 'show_advanced' || prefKey == 'beginner' || prefKey == 'show_admin') {
		//alert('DEBUG: SetPrefs: setting cookie to match LocalStorage');
		if (window.SetCookie) {
			SetCookie(prefKey, (prefValue ? 1 : 0));
		}
	}

	if (window.localStorage) {
		var nameContainer = 'settings';
		var gt = unescape('%3E');
		if (prefKey.substr(0, 2) == gt+gt) {
			nameContainer = 'voted';
		}

		var currentPrefs = localStorage.getItem(nameContainer);
		var prefsObj;
		if (currentPrefs) {
			prefsObj = JSON.parse(currentPrefs);
		} else {
			prefsObj = Object();
		}
		prefsObj[prefKey] = prefValue;

		var newPrefsString = JSON.stringify(prefsObj);
		localStorage.setItem(nameContainer, newPrefsString);
		return 0;
	}

	return 1;
}

function SaveCheckbox (ths, prefKey) { // saves value of checkbox, toggles affected elements
// id = id of pane to hide or show; not required
// ths = "this" of calling checkbox)
// prefKey = key of preference value to set with checkbox
//
// this function is a bit of a mess, could use a refactor #todo

	//alert('DEBUG: SaveCheckbox(' + ths + ',' + prefKey);

	var checkboxState = (ths.checked ? 1 : 0);
	//alert('DEBUG: checkboxState = ' + checkboxState);

	// saves checkbox's value as 0/1 value to prefs(prefKey)
	SetPrefs(prefKey, (ths.checked ? 1 : 0));


	if (prefKey == 'draggable') {
		if (ths.checked) {
			DraggingInit(0);
		} else {
			//#todo
		}
	}

	//alert('DEBUG: after SetPrefs, GetPrefs(' + prefKey + ') returns: ' + GetPrefs(prefKey));

	// call ShowAdvanced(1) to update ui appearance
	// ShowAdvanced(1);

	return 1;
}

function SetInterfaceMode (ab) { // updates several settings to change to "ui mode" (beginner, advanced, etc.)
    //alert('DEBUG: SetInterfaceMode(' + ab + ')');

	if (window.localStorage && window.SetPrefs) {
		if (ab == 'beginner') {
			SetPrefs('show_advanced', 0);
			SetPrefs('advanced_highlight', 0);
			SetPrefs('beginner', 1);
			SetPrefs('beginner_highlight', 1);
			SetPrefs('notify_on_change', 1);
			SetPrefs('show_admin', 0);
			SetPrefs('write_enhance', 0);
			SetPrefs('write_autosave', 0);
			SetPrefs('expert_timestamps', 0);
			SetPrefs('draggable', 0);
//			SetPrefs('sign_by_default', 1);
		} else if (ab == 'intermediate') {
			SetPrefs('show_advanced', 1);
			SetPrefs('advanced_highlight', 1);
			SetPrefs('beginner', 1);
			SetPrefs('beginner_highlight', 1);
			SetPrefs('notify_on_change', 1);
//            SetPrefs('show_admin', 0);
		} else if (ab == 'expert') {
			SetPrefs('show_advanced', 1);
			SetPrefs('advanced_highlight', 0);
			SetPrefs('beginner', 0);
			SetPrefs('beginner_highlight', 0);
			SetPrefs('notify_on_change', 1);
//            SetPrefs('show_admin', 0);
// 		} else if (ab == 'minimal') {
// 			SetPrefs('show_advanced', 0);
// 			SetPrefs('advanced_highlight', 0);
// 			SetPrefs('beginner', 0);
// 			SetPrefs('beginner_highlight', 0);
// 			SetPrefs('notify_on_change', 0);
// //            SetPrefs('show_admin', 0);
// 		} else if (ab == 'operator') {
//             SetPrefs('show_admin', 1);
		}

		ShowAdvanced(1);

        //alert('DEBUG: window.SetPrefs was found, and ShowAdvanced(1) was called');

		return false;
	}

	//alert('DEBUG: returning true');

	return true;
}


function LoadCheckbox (c, prefKey) { // updates checkbox state to reflect settings
// c = checkbox
// prefKey = key of preference value
//
	//alert('DEBUG: LoadCheckbox(' + c + ',' + prefKey);
	var checkboxState = GetPrefs(prefKey);
	//alert('DEBUG: checkboxState = ' + checkboxState);

	if (c && c.checked != (checkboxState ? 1 : 0)) {
		c.checked = (checkboxState ? 1 : 0);
	}

	return 1;
}


function SettingsOnload () { // onload function for settings page
	//alert('debug: SettingsOnload() begin');

	if (document.getElementById) {
	// below is code which sets the checked state of settings checkboxes
	// based on settings state
		var pane;

		//LoadCheckbox(document.getElementById('chkSignByDefault'), 'sign_by_default');
		LoadCheckbox(document.getElementById('chkDraggable'), 'draggable');
		LoadCheckbox(document.getElementById('chkShowAdmin'), 'show_admin');
		LoadCheckbox(document.getElementById('chkShowAdvanced'), 'show_advanced');
		LoadCheckbox(document.getElementById('chkWriteEnhance'), 'write_enhance');
		LoadCheckbox(document.getElementById('chkWriteEnhance'), 'write_enhance');
		LoadCheckbox(document.getElementById('chkExpertTimestamps'), 'expert_timestamps');

		//if (GetPrefs('sign_by_default') == 1) {
		//	var cbM = document.getElementById('chkSignByDefault');
		//	if (cbM) {
		//		cbM.checked = 1;
		//	}
		//}

	}

	//alert('debug: SettingsOnload: returning false');
	return false;
} // SettingsOnload()

if (window.EventLoop) {
	window.eventLoopShowAdvanced = 1;
} else {
	ShowAdvanced();
}

// == end settings.js


// == begin avatar.js

function setAva () { // sets avatar widgets (and italicizes Profile link)
	//alert('DEBUG: setAva() begins');
	
	if (document.getElementById && String.fromCharCode) {
		var myidBox = document.getElementById('myid'); // displays username (if preference is set)
		var signinBox = document.getElementById('signin'); // Profile link

		var gt = String.fromCharCode(62);

		if (myidBox && signinBox && window.localStorage) { // check for elements and features
			var myAvatar = localStorage.getItem('avatar');

			if (!myAvatar) { // less error prone than checking for ==n ull, i think
				signinBox.innerHTML = '<a href="/profile.html"' + gt + 'Profile</a' + gt + '';
			} else {
				signinBox.innerHTML = '';
				var myFp = localStorage.getItem('fingerprint');

				if (window.location.pathname == '/author/' + myFp + '/' || window.location.pathname == '/author/' + myFp + '/index.html') {
					var itsYou = document.getElementById('itsyou');
					itsYou.innerHTML = 'This is your profile!';
				}

				if (window.GetPrefs) {
					if (GetPrefs('display_username')) {
						myidBox.innerHTML = '<a href="/profile.html" class=avatar' + gt + myAvatar + '</a' + gt;
						signinBox.innerHTML = '';
					} else {
						myidBox.innerHTML = '';
						signinBox.innerHTML = '<a href="/profile.html"' + gt + '<i' + gt + 'Profile</i' + gt + '</a' + gt + '';
					}
				} else {
					myidBox.innerHTML = '';
					signinBox.innerHTML = '<a href="/profile.html"' + gt + '<i' + gt + 'Profile</i' + gt + '</a' + gt + '';
				}

				if (!window.openpgp && document.head && document.getElementById && window.localStorage) {
					//alert('DEBUG: setAva: loading openpgp.js');
					window.openPgpJsLoadBegin = 1;

					var script = document.createElement('script');
					script.src = '/openpgp.js';
					script.async = false; // This is required for synchronous execution
					document.head.appendChild(script);
				}

				if (!window.setAvatar && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
					//alert('DEBUG: setAva: loading crypto2.js');

					var script2 = document.createElement('script');
					script2.src = '/crypto2.js';
					script2.async = false; // This is required for synchronous execution
					document.head.appendChild(script2);
				}
			}
		}
	}

	return true;
} // setAva()
if (window.localStorage && document.getElementById) {
	setAva();
}

function getAvatar () { // retrieve previously built avatar from localStorage (already in html form)
	if (window.localStorage) {
		var myAvatar = localStorage.getItem("avatar");
		if (!myAvatar || myAvatar.length == 0) {
			return '';
		} else {
			return myAvatar;
		}
	} else {
		return 'Anonymous*';
	}

	return false;
} // getAvatar()

// == end avatar.js


// begin profile.js

if (!window.openpgp && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
	//alert('DEBUG: loading openpgp.js');
	window.openPgpJsLoadBegin = 1;

	var script = document.createElement('script');
	script.src = '/openpgp.js';
	script.async = false; // This is required for synchronous execution
	document.head.appendChild(script);
	//alert('DEBUG: finished loading openpgp.js; window.openpgp: ' + !!window.openpgp);
} else {
	//alert('DEBUG: not loading openpgp.js; window.openpgp: ' + !!window.openpgp + ' document.getElementById: ' + !!document.getElementById + ' window.localStorage: ' + !!window.localStorage + ' window.Promise: ' + !!window.Promise);
}

if (!(window.MakeKey) && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
	//alert('DEBUG: loading crypto2.js');

	var script2 = document.createElement('script');
	script2.src = '/crypto2.js';
	script2.async = false; // This is required for synchronous execution
	document.head.appendChild(script2);

	//alert('DEBUG: finished loading crypto2.js; window.cryptoJs: ' + !!window.cryptoJs + '; document.getPrivateKey: ' + !!document.getPrivateKey + '; window.openpgp: ' + !!window.openpgp);
} else {
	//alert('DEBUG: not loading crypto2.js; ' + ' window.MakeKey = ' + window.MakeKey + '; document.getElementById = ' + document.getElementById + ' window.localStorage = ' + window.localStorage );
}

function btnSignOut_Click(t) { // event for 'Sign Out' button's click
	//alert('DEBUG: btnSignOut_Click begin');

	if (window.localStorage) {
		//alert('DEBUG: localStorage is true');

		var ls = window.localStorage;
		ls.removeItem('privatekey');
		ls.removeItem('publickey');
		ls.removeItem('fingerprint');
		ls.removeItem('avatar');
		ls.removeItem('settings');
		ls.removeItem('voted');

		SetPrefs('last_pubkey_ping', 0);
	}

	return true;
}

function btnRegister_Click (t) { // event for 'Register' button's click
// t is clicked button's "this" object
	//alert('DEBUG: btnRegister_Click() begin');
	if (t) {
		if (t.value) {
			t.value = 'Meditate...';
		}
	}

	//if (window.localStorage && window.Promise) { // this extra check is disabled for some reason, I think IE?
	if (window.localStorage && document.getElementById) {
		//alert('DEBUG: btnRegister_Click: localStorage and Promise feature check pass');
		if (window.MakeKey) {
			//alert('DEBUG: btnRegister_Click: window.MakeKey exists, calling MakeKey()');

			var chkEnablePGP = document.getElementById('chkEnablePGP');
			if (chkEnablePGP && chkEnablePGP.checked) {
				//alert('DEBUG: chkEnablePGP is present and checked');
				var intKeyGenResult = MakeKey(t);
				//alert('DEBUG: btnRegister_Click: intKeyGenResult = ' + intKeyGenResult);
				SetPrefs('last_pubkey_ping', 1);
				//alert('DEBUG: returning intKeyGenResult = ' + intKeyGenResult);
				return intKeyGenResult;
			}
		}
	} else {
		return true;
	}

	return true;
}

function getUserFp () { // retrieve stored user fingerprint from LocalStorage
	//alert('DEBUG: getUserFp() begin');

	if (window.localStorage) {
		// LocalStorage mode
		var fingerprint = localStorage.getItem('fingerprint');
		if (fingerprint) {
			return fingerprint;
		}
	} else {
		// fallback to cookie mode
		var fingerprint = GetCookie('cookie');

		if (fingerprint) {
			return fingerprint;
		}
	}

	// nothing found, we looked everywhere
	return '';
}

function sharePubKey (t) { // shares current user's public key via injected form and iframe
	//alert('DEBUG: profile.js: sharePubKey() begins');

	if (window.getPublicKey) {
		var pubKey = getPublicKey();

		//alert('DEBUG: sharePubKey: pubKey = ' + (pubKey ? pubKey : '(false)'));

		if (pubKey) {
			if (window.displayNotification) {
				if (t) {
					displayNotification('Creating profile...', t);
				} else {
					// #todo this appears at the bottom of the page
					// probably not visible to most users
					// so the redirect is a surprise
					displayNotification('Creating profile...');
				}
			}

			//alert('DEBUG: sharePubKey: creating form');

			var form = document.createElement('form');
			form.setAttribute("action", "/post.html");
			form.setAttribute("method", "get");
			//form.setAttribute("target", "ifrSharePubKey");

			//alert('DEBUG: sharePubKey: creating input');

			var txtComment = document.createElement('input');
			txtComment.setAttribute("type", "hidden");
			txtComment.setAttribute("value", pubKey);
			txtComment.setAttribute("name", "comment");

			//alert('DEBUG: sharePubKey: adding txtComment to form');

			form.appendChild(txtComment);

			//alert('DEBUG: sharePubKey: adding form to body');

			//document.getElementsByTagName('body')[0].appendChild(form);

			document.body.appendChild(form);

			//alert('DEBUG: submitting form');

			form.submit();

			return false;
		} else {
			//alert('DEBUG: pubKey was FALSE');

			return true;
		}
	}

///// alternative method 1
//	window.open('/write.html#inspubkey', '_self');

///// alternative method 2
//	var iframe = document.createElement("iframe");
//	iframe.src = '/write.html#inspubkey';
//	iframe.name = "inspubkey"
//	iframe.style.display = 'none';
//	document.body.appendChild(iframe);

	return true;
}

function AddPrivateKeyLinks () { // adds save/load links to profile page if features are available
// #todo make it so that this can be called repeatedly and hide/show appropriate links
// this will allow to avoid having to reload profile page on status change

	//alert('DEBUG: AddPrivateKeyLinks() begin');
	if (document.getElementById && window.getPrivateKey) {
		//alert('DEBUG: AddPrivateKeyLinks: document.getElementById && window.getPrivateKey');
		var privateKey = getPrivateKey();
		var fieldset = document.getElementById('fldRegistration');

		if (fieldset && document.createElement) {
			//alert('DEBUG: AddPrivateKeyLinks: fieldset && document.createElement');

			if (privateKey) {
				//alert('DEBUG: AddPrivateKeyLinks: privateKey: true');

				// hr
				var hrDivider = document.createElement('hr');
				fieldset.appendChild(hrDivider);

				// [go to profile]
				var pProfileLink = document.getElementById('spanProfileLink');
				if (pProfileLink && pProfileLink.innerHTML) {
					// profile link already there, and contains profile link
					// #todo bind js event to profile create
				} else {
					// profile link not there or the p is empty
					if (!pProfileLink) {
						pProfileLink = document.createElement('p');
					}

					// ATTENTION!
					// THERE IS A GOTCHA HERE: THIS LINK MAY ALSO BE
					// ADDED BY PHP; THEN THIS CODE WILL NOT EXECUTE!
					// BECAUSE pProfileLink WILL ALREADY BE TRUE ABOVE

					// "Go to profile" link
					var aProfile = document.createElement('a');
					aProfile.setAttribute('href', '/author/' + getUserFp() + '/index.html');
					aProfile.setAttribute('onclick', 'if (window.sharePubKey) { return sharePubKey(this); }');
					aProfile.setAttribute('id', 'linkGoToProfile');
					aProfile.innerHTML = 'Go to profile';

					// Append both to fieldset
					pProfileLink.appendChild(aProfile);
					fieldset.appendChild(pProfileLink);

					// add horizontal rule
					var hrDivider = document.createElement('hr');
					fieldset.appendChild(hrDivider);
				}

				// [save as file]
				var pSaveKeyAsTxt = document.createElement('p');
				var aSaveKeyAsTxt = document.createElement('a');
				aSaveKeyAsTxt.setAttribute('href', '#');
				aSaveKeyAsTxt.setAttribute('id', 'linkSavePrivateKey');
				aSaveKeyAsTxt.setAttribute('onclick', 'if (window.SavePrivateKeyAsTxt) { return SavePrivateKeyAsTxt(); }');
				aSaveKeyAsTxt.innerHTML = 'Save as file';

				// hint for [save as file]
				var hintSaveKeyAsTxt = document.createElement('span');
				hintSaveKeyAsTxt.setAttribute('class', 'beginner');
				hintSaveKeyAsTxt.innerHTML = 'Save key to use again later';

				// insert [save as file] link into dom
				pSaveKeyAsTxt.appendChild(aSaveKeyAsTxt);
				var brSaveKeyAs = document.createElement('br');
				pSaveKeyAsTxt.appendChild(brSaveKeyAs);
				pSaveKeyAsTxt.appendChild(hintSaveKeyAsTxt);
				fieldset.appendChild(pSaveKeyAsTxt);

				// [show private key]
				var pShowPrivateKey = document.createElement('p');
				var aShowPrivateKey = document.createElement('a');
				pShowPrivateKey.setAttribute('class', 'advanced');
				
				aShowPrivateKey.setAttribute('href', '#');
				aShowPrivateKey.setAttribute('id', 'linkShowPrivateKey');
				aShowPrivateKey.setAttribute('onclick', 'if (window.ShowPrivateKey) { return ShowPrivateKey(); }');
				aShowPrivateKey.innerHTML = 'Show private key';
				
				// hint for [show private key]
				var hintShowPrivateKey = document.createElement('span');
				hintShowPrivateKey.setAttribute('class', 'beginner');
				hintShowPrivateKey.innerHTML = 'Display as text you can copy';

				pShowPrivateKey.appendChild(aShowPrivateKey);
				brElement = document.createElement('br');
				pShowPrivateKey.appendChild(brElement);
				pShowPrivateKey.appendChild(hintShowPrivateKey);
				fieldset.appendChild(pShowPrivateKey);
			} // privateKey is true
			else {
				//alert('DEBUG: AddPrivateKeyLinks: privateKey: false');

				// add horizontal rule
				var hrDivider = document.createElement('hr');
				fieldset.appendChild(hrDivider);

				var pLoadKeyFromTxt = document.createElement('p');

				//alert('DEBUG: AddPrivateKeyLinks: creating file input...');

				var labelLoadFromFile = document.getElementById('fileLoadKeyFromText');
				if (!labelLoadFromFile) {
					// label for "load from file" button
					var labelLoadFromFile = document.createElement('label');
					labelLoadFromFile.setAttribute('for', 'fileLoadKeyFromText');
					labelLoadFromFile.innerHTML = 'Load from file:';

					// br after label
					var brLoadFromFile = document.createElement('br');
					labelLoadFromFile.appendChild(brLoadFromFile);

					// [load from file] file selector
					var fileLoadKeyFromText = document.createElement('input');
					fileLoadKeyFromText.setAttribute('type', 'file');
					fileLoadKeyFromText.setAttribute('accept', 'text/plain');
					fileLoadKeyFromText.setAttribute(
						'onchange',
						 'if (window.openFile) { openFile(event) } else { alert("i am so sorry, openFile() function was missing!"); }'
					);
					fileLoadKeyFromText.setAttribute('id', 'fileLoadKeyFromText');
					// fileLoadKeyFromText.setAttribute('style', 'display: none');
					// i tried hiding file selector and using a button instead.
					// it looked nicer, but sometimes didn't work as expected

					// hint for [load from file]
					var hintLoadFromFile = document.createElement('span');
					hintLoadFromFile.setAttribute('class', 'beginner');
					hintLoadFromFile.innerHTML = 'Use this if you have a saved key';


					// pLoadKeyFromTxt.appendChild(aLoadKeyFromText);
					labelLoadFromFile.appendChild(fileLoadKeyFromText);
					var brLoadFromFile2 = document.createElement('br');
					pLoadKeyFromTxt.appendChild(labelLoadFromFile);
					pLoadKeyFromTxt.appendChild(brLoadFromFile2);
					pLoadKeyFromTxt.appendChild(hintLoadFromFile);


					fieldset.appendChild(pLoadKeyFromTxt);
				}
			} // privateKey is FALSE

			if (window.ShowAdvanced) {
				ShowAdvanced(1);
			}
		} // if (fieldset && document.createElement)
		else {
			//alert('DEBUG: AddPrivateKeyLinks: checks FAILED (fieldset && document.createElement)');
		}
	} else {
		//alert('DEBUG: AddPrivateKeyLinks: checks FAILED (document.getElementById && window.getPrivateKey)');
	}

	return true;
} // AddPrivateKeyLinks()

function ShowPrivateKey() { // displays private key in textarea
	//alert('DEBUG: ShowPrivateKey() begin');
	if (document.getElementById) {
		//alert('DEBUG: ShowPrivateKey: document.getElementById is true');

		var txtPrivateKey = document.getElementById('txtPrivateKey');
		if (txtPrivateKey) {
			//alert('DEBUG: ShowPrivateKey: txtPrivateKey is true');

			if (txtPrivateKey.style.display == 'none') {
				//alert('DEBUG: style is none, set to block');
				txtPrivateKey.style.display = 'block';
			} else {
				//alert('DEBUG: style is block, set to none');
				txtPrivateKey.style.display = 'none';
			}

			var linkShowPrivateKey = document.getElementById('linkShowPrivateKey');
			if (linkShowPrivateKey) {
				if (txtPrivateKey.style.display == 'none') {
					linkShowPrivateKey.innerHTML = 'Show private key';
				} else {
					linkShowPrivateKey.innerHTML = 'Hide private key';
				}
			}

			return false;
		}
	}

	if (window.getPrivateKey) {
		var privateKey = getPrivateKey();
		if (privateKey && document.createElement) {
			var txtPrivKey = document.createElement('textarea');
			txtPrivKey.setAttribute('cols', 80);
			txtPrivKey.setAttribute('rows', 24);
			txtPrivKey.setAttribute('id', 'txtPrivateKey');
			txtPrivKey.innerHTML = privateKey;

			var fldRegistration = document.getElementById('fldRegistration');
			if (fldRegistration) {
				fldRegistration.appendChild(txtPrivKey);
			} else {
				document.body.appendChild(txtPrivKey);
			}

			var linkShowPrivateKey = document.getElementById('linkShowPrivateKey');
			if (linkShowPrivateKey) {
				linkShowPrivateKey.innerHTML = 'Hide private key';
			}

			txtPrivKey.focus();

			return false;
		}
	}

	return true;
}

function openFile (event) {
	//alert('DEBUG: openFile() begin');

	var input = event.target;

	if (window.FileReader) {
		reader = new FileReader();

		// this eval is for hiding the "=function(){}" syntax from incompatible browsers
		// they shouldn't try to execute it because they don't make it here due to other tests
		eval('reader.onload = function() { var text = reader.result; LoadPrivateKeyFromTxt(text); }');
		reader.readAsText(input.files[0]);
	}

	return true;
}

function LoadPrivateKeyFromTxt (text) {
	if (window.setPrivateKeyFromTxt) {
		setPrivateKeyFromTxt(text);
	}

	return true;
}

function StripToFilename (text) { // strips provided text to only filename-valid characters
	if (!text) return '';

	text = text.trim();

	if (!text) return '';

	var charsAllowed = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';

	for (var i = 0; i < text.length; i++) {
		if (-1 < charsAllowed.indexOf(text.substr(i, 1))) {
			// ok
		} else {
			text = text.substr(0, i) + '' + text.substr(i + 1);
			i = i - 1;
		}
	}

	return text;
}

function getUsername2 () { // returns pgp username
// can be optimized with caching, but would also need to be
// un-cached when it changes. at this time, caching seems
// like over-optimization here
    var openpgp = window.openpgp;
    if (openpgp) {
		// read it into pgp object
		var privKeyObj = openpgp.key.readArmored(getPrivateKey());
		// get the public key out of it
		var pubKeyObj = privKeyObj.keys[0].toPublic();
		var myUsername = pubKeyObj.users[0].userId.userid;
		return myUsername;
	}
	return '';
} // getUsername2()

function SavePrivateKeyAsTxt() { // initiates "download" of private key as text file
	var myFp = getUserFp();
	var myUsername = getUsername2();
	var text = getPrivateKey();

	myUsername = StripToFilename(myUsername);

	return DownloadAsTxt(myUsername + '_' + myFp + '.txt', text);
}

// override cookie if we have a profile in LocalStorage
if (document.cookie) {
	//alert('DEBUG: cookie=' + document.cookie);
} else {
	//alert('DEBUG: document.cookie missing');
	if (window.localStorage) {
		//alert('DEBUG: window.localStorage exists');
		var fp = localStorage.getItem('fingerprint');
		if (fp) {
			//alert('DEBUG: fp exists, setting cookie via js');
			document.cookie = 'test=' + fp;
		}
	}
}

function PubkeyCheckProfileExists(fp) { // PLACEHOLDER checks if profile exists
// PLACEHOLDER, ALWAYS RETURNS TRUE
	//alert('DEBUG: PubkeyCheckProfileExists() begin');

	//alert('DEBUG: PubkeyCheckProfileExists: fp = ' + fp);

	var profileUrl = '/author/' + fp + '/';

	//alert('DEBUG: profileUrl = ' + profileUrl);

	if (UrlExists(profileUrl)) {
		//alert('DEBUG: lastPubKeyPing: profile exists');
		return true;
	} else {
		//alert('DEBUG: lastPubKeyPing: profile NOT FOUND');
		return false;
	}

	return true;
}

function PubKeyPing () { // checks if user's public key is on server
// uploads it to server if it is missing
//
	//alert('DEBUG: PubKeyPing() begin');

	var lastPing = GetPrefs('last_pubkey_ping');

	if (lastPing && (time() < (lastPing + 3600))) {
		//alert('DEBUG: PubKeyPing: lastPing+10 = ' + (lastPing+10) + ' < time() = ' + time());
	} else {
		//alert('DEBUG: PubKeyPing: lastPing was false or stale, doing a check at ' + time());

		if (window.location.href.indexOf('profile') != -1 && window.getUserFp) {
			//alert('DEBUG; PubKeyPing: window.getUserFp check passed');

			var myFingerprint = getUserFp();

			//alert('DEBUG: PubKeyPing: myFingerprint = ' + myFingerprint);

			if (myFingerprint) {
				if (PubkeyCheckProfileExists(myFingerprint)) {
					//alert('DEBUG: PubKeyPing: profile already exists');
				} else {
					if (window.sharePubKey) {
						//alert('DEBUG: PubKeyPing: lastPing: window.sharePubKey check passed, doing it...');
						sharePubKey();

						lastPing = time();
						SetPrefs('last_pubkey_ping', lastPing);
					} else {
						//alert('DEBUG: PubKeyPing: lastPing: window.sharePubKey check FAILED');
					}
				}
			} else {
				//alert('DEBUG: PubKeyPing: myFingerprint: false');
			}

			//alert('DEBUG: PubKeyPing: lastPing check complete, saving time');
		} else {
			//alert('DEBUG: PubKeyPing: window.getUserFp check FAILED');
		}
	}

	return true;
} // PubKeyPing()

function ProfileOnLoad () { // onload event for profile page
	//alert('DEBUG: ProfileOnLoad() begin');

	if (document.getElementById) {
		//alert('DEBUG: ProfileOnLoad: document.getElementById check passed');

		var lblSigningIndicator = document.getElementById('lblSigningIndicator');

		if (window.getPrivateKey) {
			//alert('DEBUG: ProfileOnLoad: window.getPrivateKey check passed');

			if (window.localStorage) {
				//alert('DEBUG: ProfileOnLoad: window.localStorage check passed, calling getPrivateKey()...');

				var pk = getPrivateKey();

				if (pk) {
					//alert('DEBUG: ProfileOnLoad: pk = GetPrivateKey() = ' + !!pk);
					// span used to indicate whether openpgp signing is available
					if (lblSigningIndicator) {
						//alert('DEBUG: lblSigningIndicator TRUE');
						// display value of "algorithm" which openpgp gives us
						// in reality, this only give us rsa/not-rsa, and formatted poorly
						// there's the bit count and the actual algo for non-rsa which needs
						// to be displayed more nicely here
						var privKeyObj = openpgp.key.readArmored(pk);
						var pubKeyObj = privKeyObj.keys[0].toPublic();

						var myAlgo = pubKeyObj.primaryKey.algorithm.toString();
						if (myAlgo) {
							lblSigningIndicator.innerHTML = myAlgo;
						} else {
							lblSigningIndicator.innerHTML = 'Yes';
						}
						AddPrivateKeyLinks();
					} else {
						//alert('DEBUG: lblSigningIndicator FALSE');
					}


					lblHandle = document.getElementById('lblHandle');

					if (lblHandle) {
						var strHandle = localStorage.getItem('avatar');
						if (strHandle) {
							lblHandle.innerHTML = strHandle;
						}
					}

					lblFingerprint = document.getElementById('lblFingerprint');

					if (lblFingerprint) {
						var strFingerprint = localStorage.getItem('fingerprint');
						if (strFingerprint) {
							lblFingerprint.innerHTML = strFingerprint;
						}
					}

					//alert('DEBUG: ProfileOnLoad: calling PubKeyPing()');
					PubKeyPing();
				} // pk is true
				else {
					//alert('DEBUG: pk = false')
					if (lblSigningIndicator) {
						//alert('DEBUG: lblSigningIndicator check passed');
						if (window.openpgp) {
							// #todo why is window.openpgp false here??
							//alert('DEBUG: window.openpgp check passed, setting no (available)');

							lblSigningIndicator.innerHTML = '';

							var lblEnablePGP = document.createElement('label');
							var chkEnablePGP = document.createElement('input');
							var txtEnablePGP = document.createTextNode('PGP');

							chkEnablePGP.setAttribute('type', 'checkbox');
							chkEnablePGP.setAttribute('name', 'chkEnablePGP');
							chkEnablePGP.setAttribute('id', 'chkEnablePGP');

							lblEnablePGP.setAttribute('for', 'chkEnablePGP');

							lblEnablePGP.appendChild(chkEnablePGP);
							lblEnablePGP.appendChild(txtEnablePGP);
							lblSigningIndicator.appendChild(lblEnablePGP);

							AddPrivateKeyLinks();
						} else {
							//alert('DEBUG: warning: window.openpgp check FAILED');
							lblSigningIndicator.innerHTML = 'Nope';
						}
					} else {
						//alert('DEBUG: lblSigningIndicator check FAILED');
					}
					AddPrivateKeyLinks();
				}
			} else {
				//alert('DEBUG: ProfileOnLoad: window.localStorage check FAILED');
			}
		} else {
			//alert('debug: ProfileOnLoad: window.getPrivateKey check FAILED');
		}
	} else {
		//alert('DEBUG: ProfileOnLoad: document.getElementById check FAILED');
	}

	return true;
}

function SetCookie (cname, cvalue, exdays) { // set cookie
	var d = new Date();
	d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
	var expires = "expires="+d.toUTCString();
	document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
	var testSetCookie = GetCookie(cname);
	if (cvalue == testSetCookie) {
		return 1;
	} else {
		return 0;
	}
} // SetCookie()

function GetCookie (cname) { // get cookie value
	// in js, cookies are accessed via one long string of the form
	// key1=value1; key2=value2;
	// so we make an array, splitting the string using the ; separator
	var ca = document.cookie.split(';');

	// the value we are looking for will be prefixed with cname=
	var name = cname + "=";

	for(var i = 0; i < ca.length; i++) {
		// loop through ca array until we find prefix we are looking for
		var c = ca[i];
		while (c.charAt(0) == ' ') {
			// remove any spaces at beginning of string
			c = c.substring(1);
		}
		if (c.indexOf(name) == 0) {
			// if prefix matches, return value
			return c.substring(name.length, c.length);
		}
	}

	// at this point, nothing left to do but return empty string
	return "";
}

// end profile.js


// puzzle.js

if (document.createElement && document.head) {
// include sha512.js library instead of embedding it in page
// because it's big and contains (gt) characters
// and because it is large
	var script = document.createElement('script');
	script.src = '/sha512.js';
	script.async = false; // This is required for synchronous execution
	document.head.appendChild(script);
}

function doSolvePuzzle () { // solves puzzle
// called from a timeout set by solvePuzzle()
	var fp = '0000000000000000';
	if (window.getUserFp) {
		fp = getUserFp();
	}
	// user's fp or default to 000

	var i = 0; // counts iterations
	var done = 0; // done status

	var d = new Date();
	var epoch = d.getTime();
	epoch = Math.ceil(epoch / 1000); // current time in epoch format

	var r = 0 + ''; // stores random number as string
	var lookingFor = '1337'; // required hash prefix
	var lookingForLength = lookingFor.length;
	var cycleLimit = 1000000; // give up after this many tries
	var puzzle = ''; // finished puzzle
	var hash = ''; // hash of puzzle

	while(!done) {
		// look for a puzzle which fits criteria
		i = i + 1; // counter
		r = Math.random() + '';
		puzzle = fp + ' ' + epoch + ' ' + r;
		hash = hex_sha512(puzzle);
		if (hash.substring(0, lookingForLength) == lookingFor) {
			// match found
			done = 1;
		}
		if (cycleLimit < i) {
			// give up
			done = 2;
		}
	} // while(!done) -- solving puzzle

	// add to compose form, sign, and submit
	var txtComment = document.compose.comment;
	if (txtComment && window.solvePuzzle) {
		var puzzleResult = '';
		if (done == 1) {
			puzzleResult = puzzle;
		} else {
			puzzleResult = 'puzzle not solved, even after ' + i + ' tries';
		}
		if (txtComment.value.substr(txtComment.value.length - 2, 2) == "\n\n") {
			txtComment.value += puzzleResult;
		} else {
			if (txtComment.value.substr(txtComment.value.length - 1, 1) == "\n") {
				txtComment.value += "\n" + puzzleResult;
			} else {
				txtComment.value += "\n\n" + puzzleResult;
			}
		}
	}
	var btnSolvePuzzle = document.getElementById('btnSolvePuzzle');
	if (window.signMessage) {
		if (btnSolvePuzzle) {
			btnSolvePuzzle.value = 'Signing...';
		}
		signMessage();
	}
	if (window.writeSubmit) {
		writeSubmit();
		if (btnSolvePuzzle) {
			btnSolvePuzzle.value = 'Sending...';
		}
	}
} // doSolvePuzzle()

function solvePuzzle (t) { // t = button pressed ; begins puzzle solving process and indicates to user
// done with timeout to give button a chance to change caption before pegging cpu

	if (!window.hex_sha512 || !window.doSolvePuzzle) {
		// required function is missing
		return true;
	}
	if (t) {
		// update button caption
		t.value = 'Solving...';
	}

	// set timeout to solve puzzle
	var timeoutSolvePuzzle = setTimeout('doSolvePuzzle()', 500);

	return false; // do not let the calling form submit, doSolvePuzzle() will do it
} // solvePuzzle()

// / puzzle.js


// == begin fresh.js
var freshClient;
//
//function ReplacePageWithNewContent () {
//	window.location.replace(window.newPageLocation);
//	document.open();
//	document.write(window.newPageContent);
//	document.close();
//
//	return 0;
//}
//
//function StoreNewPageContent () {
//	var xmlhttp = window.xmlhttp2;
//
//	if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
//		//alert('DEBUG: PingUrlCallbackReplaceCurrentPage() found status 200');
//		window.newPageContent = xmlhttp.responseText;
//		window.newPageLocation = xmlhttp.responseURL;
//
//		//window.location.replace(xmlhttp.responseURL);
////		document.open();
////		document.write(xmlhttp.responseText);
////		document.close();
//	}
//}
//
//function FetchNewPageContent (url) {
//	if (window.XMLHttpRequest) {
//		//alert('DEBUG: PingUrl: window.XMLHttpRequest was true');
//
//		var xmlhttp;
//		if (window.xmlhttp2) {
//			xmlhttp = window.xmlhttp2;
//		} else {
//			window.xmlhttp2 = new XMLHttpRequest();
//			xmlhttp = window.xmlhttp2;
//		}
//        xmlhttp.onreadystatechange = window.StoreNewPageContent;
//        xmlhttp.open("GET", url, true);
//		xmlhttp.setRequestHeader('Cache-Control', 'no-cache');
//        xmlhttp.send();
//
//        return false;
//	}
//}


function freshCallback() { // callback for requesting HEAD for current page
//alert('DEBUG: freshCallback() this.readyState = ' + this.readyState);

//	if (1 || this.readyState == this.HEADERS_RECEIVED) { // headers received -- what we've been waiting for
	if (
		document.getElementById &&
		this.readyState == this.HEADERS_RECEIVED ||
		this.status == 200
	) { // headers received -- what we've been waiting for
		// document.title = 'DEBUG: callback received 200';
	    //alert('DEBUG: freshCallback() this.readyState == this.HEADERS_RECEIVED');

		var eTag = freshClient.getResponseHeader("ETag"); // etag header contains page 'fingerprint'

		//alert('DEBUG: eTag = ' + eTag);

		if (eTag) { // if ETag header has a value
			if (window.myOwnETag) {
				if (eTag != window.myOwnETag) {
					if (eTag == window.lastEtag) { // if it's equal to the one we saved last time
						// no new change change
					} else {
						var freshUserWantsReload = 0;  // templated
						if (freshUserWantsReload) {
							// user wants reload
							//alert('DEBUG: user wants automatic page reload');
							location.reload();
						} else {
							// user doesn't want reload, just show notification
							//alert('DEBUG: user does not want automatic page reload, notify');
							window.lastEtag = eTag;

							var ariaAlert;
							ariaAlert = document.getElementById('ariaAlert');

							if (!ariaAlert) {
								//alert('DEBUG: ariaAlert created successfully');
								ariaAlert = document.createElement('p');
								ariaAlert.setAttribute('role', 'alert');
								ariaAlert.setAttribute('id', 'ariaAlert');
								ariaAlert.style.zIndex = '1337'; //#todo

								var txtUpdated = document.createTextNode('Page updated ');
								ariaAlert.appendChild(txtUpdated);

								//document.body.appendChild(ariaAlert);
								document.body.insertBefore(ariaAlert, document.body.firstChild);
								//window.newPageContent =
								//FetchNewPageContent(window.mypath + '?' + new Date().getTime());

								//ariaAlert.innerHTML = ariaAlert.innerHTML + '+';
								var d = new Date();
								var n = d.getTime();
								n = Math.ceil(n / 1000);

								var space = document.createElement('span');
								space.innerHTML = ' ';
								ariaAlert.appendChild(space);

								var a = document.createElement('a');
								a.setAttribute('id', 'freshAria');
								a.setAttribute('href', '#');
								a.setAttribute('onclick', 'location.reload()');
								ariaAlert.appendChild(a);

								var newTs = document.createElement('span');
								newTs.setAttribute('class', 'timestamp');
								newTs.setAttribute('epoch', n);
								newTs.setAttribute('id', 'freshTimestamp');
								newTs.innerHTML = 'just now!';
								a.appendChild(newTs);
							} // !ariaAlert

							if (window.freshTimeoutId) {
								clearTimeout(window.freshTimeoutId);
							}
							//window.eventLoopFresh = 0; // stop checking for updates

							if (document.title.substring(0, 2) != '! ') {
								document.title = '! ' + document.title;
							}
						} // NOT freshUserWantsReload
					} // lastEtag also didn't match
				} // eTag != window.myOwnETag
				else {
					//document.title = 'freshCallback: x ' + window.myOwnETag + ';' + new Date().getTime();
					if (window.freshTimeoutId) {
						clearTimeout(window.freshTimeoutId);
					}
					window.freshTimeoutId = setTimeout('CheckIfFresh()', 15000);
				}
			} // if (window.myOwnETag)
			else {
				window.myOwnETag = eTag;
			}
		} // if (eTag) // ETag header has value
	} // status == 200
	if (this.status == 404 && document.getElementById) {
		//alert('DEBUG: page has gone away on server (404)');
		var ariaAlert;
		ariaAlert = document.getElementById('ariaAlert');
		if (!ariaAlert) {
			ariaAlert = document.createElement('p');
			ariaAlert.setAttribute('role', 'alert');
			ariaAlert.setAttribute('id', 'ariaAlert');
			ariaAlert.style.zIndex = '1337'; //#todo
			ariaAlert.innerHTML = 'Page deleted';

			//document.body.appendChild(ariaAlert);
			document.body.insertBefore(ariaAlert, document.body.firstChild);
		}
		// window.eventLoopFresh = 0; // stop checking for updates
	} // status == 404

	return true;
} //freshCallback()

function CheckIfFresh () {
	var d = new Date();
	//alert('debug: CheckIfFresh: ' + d.getTime());

	var freshCheckRecent = window.freshCheckRecent;
	if (freshCheckRecent) {
		//alert('debug: CheckIfFresh: freshCheckRecent = ' + freshCheckRecent);
		var d = new Date();
		var curTime = d.getTime();
		if (curTime < freshCheckRecent + 3000) {
			return true;
		}
	}
	//alert('debug: CheckIfFresh: checkpoint passed');

	var d = new Date();
	window.freshCheckRecent = d.getTime();

	var xhr = null;
	if (window.XMLHttpRequest){
    	xhr = new XMLHttpRequest();
    }
    else {
    	if (window.ActiveXObject) {
    		xhr = new ActiveXObject("Microsoft.XMLHTTP");
		}
    }

	if (xhr) {
		var mypath = window.mypath;

		if (!mypath) {
			mypath = window.location;
			window.mypath = mypath;
		}

		freshClient = xhr;

		if (0 && mypath.toString().indexOf('?') == -1) {
			// this ensures no caching, but may cause other problems
			freshClient.open("HEAD", mypath + '?' + d.getTime(), true);
		} else {
			freshClient.open("HEAD", mypath, true);
		}

    	//freshClient.timeout = 5000; //#xhr.timeout
		freshClient.setRequestHeader('Cache-Control', 'no-cache');
		freshClient.onreadystatechange = freshCallback;

		freshClient.send();
	}

	return true;
} // CheckIfFresh()
//
//if (window.GetPrefs) {
//	var needNotify = (GetPrefs('notify_on_change') ? 1 : 0);
//	if (needNotify == 1) { // check value of notify_on_change preference
//		if (window.EventLoop) {
//			EventLoop();
//		} else {
//			CheckIfFresh();
//		}
//	}
//}

//alert('DEBUG: fresh.js');

// == end fresh.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->
</body></html>
<!-- InjectJs2: back_to_top_button -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin back_to_top_button.js
function showBackToTop () { // show or hide "back to top" button depending on vertical scroll state
    var pageOffset = document.body.scrollTop;

    if (100 < pageOffset) {
    	if (window.showBackToTopLastAction != 1) {
//			var colorBody = document.body.style.backgroundColor || document.body.getAttribute('bgcolor'));
//			var colorButton = document.getElementById('aBackToTop').style.backgroundColor;
//
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#002000'", 250);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#004000'", 500);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#006000'", 750);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#008000'", 1000);

			document.getElementById('aBackToTop').style.visibility = 'visible';
			window.showBackToTopLastAction = 1;
		}
    } else {
    	if (window.showBackToTopLastAction != 0) {
        	document.getElementById('aBackToTop').style.visibility = 'hidden';
        	window.showBackToTopLastAction = 0;
		}
    }

    return true;
} // showBackToTop()

if (document.getElementById) { // enable window.onscroll if getElementById exists
    window.onscroll = window.showBackToTop;
    showBackToTop();
}
// end back_to_top_button.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->

<!-- InjectJs2: loading_end -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin loading_end.js

function HideLoadingIndicator () {
	if (!document.getElementById) {
		return '';
	}

	var loadingIndicator = window.loadingIndicator;

	if (!loadingIndicator) {
		if (document.getElementById) {
			loadingIndicator = document.getElementById('loadingIndicator');
		}
	}

	if (window.loadingIndicatorShowTimeout) {
		clearTimeout(loadingIndicatorShowTimeout);
	}

	loadingIndicator.innerHTML = 'Ready.';
//	loadingIndicator.style.backgroundColor = '$colorHighlightAdvanced';

	window.loadingIndicator = loadingIndicator;

	setTimeout('if (window.loadingIndicator) { window.loadingIndicator.style.display = "none"; }', 3000); //#todo
	// } else {
	// 	if (loadingIndicator) { loadingIndicator.style.display = 'none' }
	// }
	return '';
} // HideLoadingIndicator()

function WaitForOpenPgp () {
	//alert('debug: WaitForOpenPgp()');
	var d = new Date();
	if (window.openPgpJsLoadBegin && window.openpgp) {
		HideLoadingIndicator();
	} else {
		setTimeout('if (window.WaitForOpenPgp) { WaitForOpenPgp() }', 500);
	}
} // WaitForOpenPgp()

if (!window.OnLoadEverything && window.HideLoadingIndicator) {
	HideLoadingIndicator();
}

// end loading_end.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->
