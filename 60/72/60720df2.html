<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
<title>Information</title>
<style type="text/css">
<!--
/* begin css/default.css */
.tag-flag,
.tag-troll,
.tag-spam,
.tag-remove,
.tag-abuse {
/* negative (red) tags */
	color: #c00000;
}

.tag-remove {
/* remove tag */
	font-weight: bold;
}

.tag-approve,
.tag-accept,
.tag-friend,
.tag-attend {
/* positive (green) tags */
	color: #008000;
}

div.reply {
/* creates indented effect for sub-replies */
	margin-left: 2%;
	padding-left: 3em;
}

.item-textart {
/* textart items get monospace font */
	font-family: monospace;
	font-size: 12pt;
}

.tag-aolart {
/* aol art in 10-point arial font */
    font-family: Arial;
    font-size: 10pt;
}

div.txt {
	padding-left: 1em;
}

.byadmin {
/* text by admin, displayed in red for users' sake */
	color: red;
}

.signed {
/* signed things are displayed in gold */
    border-color: gold;
}


#eventLocation, #eventBrcLocation {
/* event form */
	background-color: #ffffff;
	padding: 5pt;
}

#eventDate {
/* event form */
	background-color: #e0e0e0;
	padding: 5pt;
}

#loadingIndicator, #spanLoadingIndicator, #ariaAlert {
	color: #000000;
	background-color: #f0f0d0;
	padding: 3pt;
	position: fixed;
	top: 0;
	left: 0;
	margin: 0;
	font-family: tahoma, arial, sans-serif;
	font-size: smaller;
	font-weight: bold;
}
#loadingIndicator a {
	/* style for links in loading indicator */
}
.notification {
	color: #000000;
	background-color: #f0f0d0;
	padding: 3pt;
	font-size: smaller;
	font-weight: bold;
}
noscript {
	color: red;
}
.menubar a, .titlebar a {
	text-decoration: none;
	color: #000000;
}
/* end css/default.css */

/* avatar.css */
.avatar .icon {
	font-weight: bold;
	font-size: smaller;
}
/* / avatar.css */

/* dragging.css */

table.dialog {
	display: inline-block;
	vertical-align: top;
}
form {
	display: inline;
}

/* / dragging.css */

/* theme/mitbtc/additional.css */
/* / theme/mitbtc/additional.css */
/* theme/chicago/additional.css */
body {
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	background-color: #008080;
}
input {
	border-color: blue;
}
input[type=text], input[type=password], select, option, textarea {
	background-color: #ffffff;
	color: #000000;
}
#txtClock {
	border: 1pt inset #c0c0c0;
}
@media (prefers-color-scheme: dark) {

}
.beginner {
    background-color: #f0f0d0;
}
.dialog {
	box-shadow: 3pt 3pt 0 rgba(0, 20, 20, 0.5);
	border: #c0c0c0 outset 2pt;
	background-color: #c0c0c0;
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	font-size: 10pt;
}
.statusbar td {
	border: 1pt inset #c0c0c0;
}
textarea {
    font-family: Fixedsys, "Courier New", Courier, monospace;
    font-size: 12pt;
}

.txt {
/* regular text */
	font-family: Tahoma, Arial, Helvetica, sans-serif;
	font-size: 14pt;
	background-color: #d0d2d4;
	border: 1pt #ffffff inset;
}

a:focus, a:active {
    color: red !important;
    background-color: orange !important;
}
textarea:focus {
    background-color: #fff0e0;
}
input:focus {
    background-color: orange;
}
#serverResponse {
/* response messages from the server */
    background-color: #ffc080;
    color: #000000;
    padding: 5pt;
    spacing: 5pt;
    border: 0;
	box-shadow: 5pt 5pt 0 rgba(0, 20, 20, 0.5);
}
#txtClock {
	border: 1pt inset #c0c0c0;
	background-color: #c0c0c0;
}
/* / theme/chicago/additional.css */
-->
</style>
</head>
<body background="/triangles.gif" onbeforeunload="if (window.ShowPreNavigateNotification){ ShowPreNavigateNotification();}" onclick="if (event.target && (event.target.tagName == 'A') && !(event.target.onclick)) { ShowPreNavigateNotification(); }" onload="if (window.OnLoadEverything) { OnLoadEverything(); }" >
<!-- InjectJs2: loading_begin -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin loading_begin.js

//var loadingIndicatorWaitToShowMin = 1500;
//var loadingIndicatorWaitToHideMin = 500;

function addLoadingIndicator (strMessage) { // adds loading indicator bar (to top of page, depending on style)
	//alert('DEBUG: addLoadingIndicator(' + strMessage + ')');
	if (!strMessage) {
		//alert('DEBUG: strMessage = ' + strMessage);
		strMessage = 'Meditate...';
	}
	//alert('DEBUG: addLoadingIndicator: strMessage = ' + strMessage);

	if (!document.createElement) {
		//alert('DEBUG: addLoadingIndicator: warning: no document.createElement');
		return '';
		// #todo improve compatibility here
	}

	//alert('DEBUG: addLoadingIndicator: sanity checks passed!');
	var spanLoadingIndicator = document.createElement('span');
	if (spanLoadingIndicator) {
		spanLoadingIndicator.setAttribute('id', 'loadingIndicator');
		spanLoadingIndicator.innerHTML = strMessage;
		spanLoadingIndicator.zIndex = 1337;
		document.body.appendChild(spanLoadingIndicator);
	}

	return '';

} // addLoadingIndicator()

if (document.createElement) {
	//alert('DEBUG: loading_begin.js: createElement feature check PASSED!');
	var d = new Date();
	var loadingIndicatorStart = d.getTime() * 1;
	var gt = unescape('%3E');

	//var loadingIndicatorloadCounter = 0;
	addLoadingIndicator('Meditate...');
} else {
	//alert('DEBUG: loading_begin.js: createElement feature check FAILED!');
}
// end loading_begin.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->

<b></b>
<p><!-- mitbtc/template/topmenu2.template -->
<table cellspacing=0 cellpadding=3 border=0 bgcolor="#c0c0c0" class=dialog>
	<tr bgcolor="#35163A">
		<td colspan=2>
			<img alt="MIT Bitcoin Expo" title="MIT Bitcoin Expo" logo src="/logo.gif" height=16 width=16>
			<font color="#ffffff"><b>MIT Bitcoin Expo 2021</b></font>
			<a href="/etc.html" onclick="if (window.ShowAll) { ShowAll(this); } if (window.DraggingInit) { DraggingInit(0); } return false;" >.</a>
			<br>
		</td>
	</tr>
	<tr bgcolor="#c0c0c0" class=menubar>
		<td>
			<big>
				<big><!-- menuitem.template -->
<a accesskey="h" href="/"><u>H</u>ome</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="r" href="https://tinyurl.com/4ezdhdk"><u>R</u>egister</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="s" href="/speakers.html"><u>S</u>peakers</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="p" href="/sponsors.html">S<u>p</u>onsors</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="m" href="/media.html"><u>M</u>edia Partners</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="a" href="/academic.html"><u>A</u>cademic Partners</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="g" href="/agenda.html">A<u>g</u>enda</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="c" href="https://mit-bitcoin-expo-hackathon.devfolio.co/">Ha<u>c</u>kathon</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="o" href="/committee.html">C<u>o</u>mmittee</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="l" href="/links.html"><u>L</u>inks</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="i" href="https://eepurl.com/gOVdKb">Ma<u>i</u>ling List</a>
<!-- / menuitem.template -->
 &nbsp; <!-- menuitem.template -->
<a accesskey="e" href="/flashback_2020/">Prior <u>E</u>xpo</a>
<!-- / menuitem.template -->
 &nbsp; </big>
			</big>
		</td>
	</tr>
</table>
<!-- / mitbtc/template/topmenu2.template -->
<MAIN ID=maincontent><A NAME=maincontent></A>
<!-- window/standard.template -->
<font face=arial>
	<table cellspacing=0 cellpadding=6 border=0 bgcolor="#c0c0c0" class=dialog>
		<!-- titlebar_with_button.template -->
<tr bgcolor="#35163A" class=titlebar>
	<td valign=middle>
		<img alt="[-]" title="Window Icon" logo src="/logo.gif" height=16 width=16>
		<font color="#ffffff"><b>Information</b></font>
		<br>
	</td>
</tr>
<!-- / titlebar_with_button.template -->


		

		

		<tr class=content><td><!-- item/item.template -->
<p class="txt">&gt;&gt;<a href="/5a/8d/5a8d7a5e.html">5a8d7a5e..</a><br><br>asdfadsf <br>a<br>sdf<br><br></p>
<!-- / item/item.template -->
</td></tr>

		<!-- window/status.template -->
<tr class=statusbar>
	<td>
		<!-- status_bar.template -->
<a href="/60/72/60720df2.html">asdfadsf </a>
<!-- status_bar.template -->

	</td>
</tr>
<!-- / window/status.template -->

	</table>
</font>
<!-- / window/standard.template -->
<a name=ee3137ed></a><replies></replies></main>
<hr>
<img src="/p.gif" alt="" height=1 width=1>
<!-- back_to_top_button.template -->
<a
    href="#"
    onclick="if (window.scrollTo) { window.scrollTo(0, 0); return false; }"
    title="Back to top"
    id=aBackToTop
    style="
        position: fixed;
        right: 5pt;
        bottom: 5pt;
        background-color: #f0f0d0;
        border: 5pt;
        padding: 5pt;
        border-radius: 5pt;
        text-decoration: none;
    "
>^^</span></a>
<!-- / back_to_top_button.template -->
<!-- InjectJs: settings avatar voting utils profile translit write write_buttons timestamp fresh -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// == begin settings.js

var showAdvancedLastAction = '';
var showBeginnerLastAction = '';
var showMeaniesLastAction = '';
var showAdminLastAction = '';
var showTimestampsLastAction = '';

var timerShowAdvanced;

function SetElementVisible (element, displayValue, bgColor, borderStyle) { // sets element's visible status based on tag type
// displayValue = 'none' or 'initial'
// 	when 'initial', will try to substitute appropriate default for tag type
// also sets background color
// used for hiding/showing and highlighting beginner, advanced element classes on page.

    //alert ('DEBUG: \nelement:' + element + "\ndisplayValue:" + displayValue + "\nbgColor:" + bgColor + "\nborderStyle:" + borderStyle + "\n");

	if (bgColor) {
		// background color
		if (bgColor == 'initial') {
			bgColor = '#c0c0c0';
		}
		element.style.backgroundColor = bgColor;
		// this may cause issues in some themes
	}

	// depending on element type, we set different display style
	// block, table-row, table-cell, or default of 'initial'
	if (displayValue == 'initial' && (element.nodeName == 'P' || element.nodeName == 'H3' || element.nodeName == 'FIELDSET' || element.nodeName == 'HR')) {
		element.style.display = 'block';
	} else if (displayValue == 'initial' && element.nodeName == 'TR') {
		element.style.display = 'table-row';
	} else if (displayValue == 'initial' && (element.nodeName == 'TH' || element.nodeName == 'TD')) {
		if (element.innerHTML != '') {
			element.style.display = 'table-cell';
		} else {
			element.style.display = 'none'; // empty table cells display = none #why?
		}
	} else {
		if (displayValue == 'initial') {
			displayValue = 'inline';
		}
		element.style.display = displayValue;
		if (borderStyle) {
			// border style
			element.style.border = borderStyle;
			//element.style.borderRadius = '3pt';
		}
	}

	return 1;
} // SetElementVisible()

function ShowAll (t, container) { // t = clicked link ; container = document by default ; shows all elements, overriding settings
// admin elements are excluded. only beginner, advanced class elements are shown
	var gt = unescape('%3E');

	if (!container) {
		container = document;
	}

	var isMore = 1;
	if (t.innerHTML == 'Less') {
		// when without accesskey
		t.innerHTML = 'More';
		isMore = 0;
	}
	if (t.innerHTML == 'Less (<u' + gt + 'O</u' + gt + ')') {
		// when with accesskey
		t.innerHTML = 'M<u' + gt + 'o</u' + gt + 're';
		isMore = 0;
	}

    if (isMore && container.getElementsByClassName) {
		if (t.innerHTML == 'More') {
			// without accesskey
			t.innerHTML = 'Less';
		}
		if (t.innerHTML == 'M<u' + gt + 'o</u' + gt + 're') {
			// with accesskey
			t.innerHTML = 'Less (<u' + gt + 'O</u' + gt + ')';
		}

        var display;
        display = 'initial';

        var elements = container.getElementsByClassName('advanced');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], display, '#ffe0e0', 0);
        }
        elements = container.getElementsByClassName('beginner');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], display, '#f0f0d0', 0);
        }
        elements = container.getElementsByClassName('expand');
        for (var i = 0; i < elements.length; i++) {
            SetElementVisible(elements[i], 'none', '', 0);
        }

        if (timerShowAdvanced) {
            clearTimeout(timerShowAdvanced);
        }
		//timerShowAdvanced = setTimeout('ShowAdvanced(1);', 10000);
		//
		//if (t && t.getAttribute('onclick')) {
		//t.setAttribute('onclick', '');
		//}
		//if (window.ArrangeAll) {
		//	ArrangeAll();
		//}

        return false;
    } else {
    	ShowAdvanced(1);

    	return false;
	}

    return true;
} // ShowAll()

function ShowAdvanced (force, container) { // show or hide controls based on preferences
//handles class=advanced based on 'show_advanced' preference
//handles class=beginner based on 'beginner' preference
//force parameter
// 1 = does not re-do setTimeout (called this way from checkboxes)
// 0 = previous preference values are remembered, and are not re-done (called by timer)

	//alert('DEBUG: ShowAdvanced(' + force + ')');

	if (!container) {
		container = document;
	}

	if (document.getElementById && window.localStorage && container.getElementsByClassName) {
		//alert('DEBUG: ShowAdvanced: feature check passed!');
		///////////

		var displayTimestamps = '0';
		if (GetPrefs('expert_timestamps')) {
			displayTimestamps = 1;
		}
		if (force || window.showTimestampsLastAction != displayTimestamps) {
			//ShowTimestamps();
			window.showTimestampsLastAction = displayTimestamps;
		}

		var displayAdmin = 'none'; // not voting by default
		if (GetPrefs('show_admin') == 1) { // check value of show_admin preference
			displayAdmin = 'initial'; // display
		}
		if (force || showAdminLastAction != displayAdmin) {
			var elemAdmin = container.getElementsByClassName('admin');

			for (var i = 0; i < elemAdmin.length; i++) {
				SetElementVisible(elemAdmin[i], displayAdmin, 0, 0);
			}
		}

		var displayValue = 'none'; // hide by default
		if (GetPrefs('show_advanced') == 1) { // check value of show_advanced preference
			displayValue = 'initial'; // display
		}

		var bgColor = 'initial';
		if (GetPrefs('advanced_highlight') == 1) { // check value of advanced_highlight preference
			bgColor = '#ffe0e0'; // advanced_highlight
		}

		if (force || showAdvancedLastAction != (displayValue + bgColor)) {
			// thank you stackoverflow
			var divsToHide = container.getElementsByClassName("advanced"); //divsToHide is an array #todo nn3 compat
			for (var i = 0; i < divsToHide.length; i++) {
				//divsToHide[i].style.visibility = "hidden"; // or
				SetElementVisible(divsToHide[i], displayValue, bgColor, 0);
			}
//			var clock = document.getElementById('txtClock');
//			if (clock) {
//			    SetElementVisible(clock, displayValue, bgColor, 0);
//			}
			showAdvancedLastAction = displayValue + bgColor;
		}

		displayValue = 'initial'; // show by default
		if (GetPrefs('beginner') == 0) { // check value of beginner preference
			displayValue = 'none';
		}

		bgColor = 'initial';
		if (GetPrefs('beginner_highlight') == 1) { // check value of beginner preference
			bgColor = '#f0f0d0'; // beginner_highlight
		}

		if (force || showBeginnerLastAction != displayValue + bgColor) {
			var divsToShow = container.getElementsByClassName('beginner');//#todo nn3 compat

			for (var i = 0; i < divsToShow.length; i++) {
				SetElementVisible(divsToShow[i], displayValue, bgColor, 0);
			}
			showBeginnerLastAction = displayValue + bgColor;
		}
//
//		if (window.freshTimeoutId) {
//			// reset the page change notifier state
//			clearTimeout(window.freshTimeoutId);
//
//			if (GetPrefs('notify_on_change')) {
//				// check if page has changed, notify user if so
//				if (window.EventLoop) {
//					EventLoop();
//				}
//			}
//		}

		if (window.setAva) {
			setAva(); // #todo caching similar to above
		}

		//if (!force) {
			//if (timerShowAdvanced) {
			//	clearTimeout(timerShowAdvanced);
			//}
			//timerShowAdvanced = setTimeout('ShowAdvanced()', 3000);
		//}

		//SettingsOnload();

	} else {
		//alert('DEBUG: ShowAdvanced: feature check FAILED!');
		//alert('DEBUG: window.localStorage: ' + window.localStorage + '; document.getElementsByClassName: ' + document.getElementsByClassName);
	}

	//alert('DEBUG: ShowAdvanced: returning false');
	return false;
} // ShowAdvanced()

function GetPrefs (prefKey) { // get prefs value from localstorage
	// GetConfig {
	// GetSetting {
	//alert('debug: GetPrefs(' + prefKey + ')');
	if (window.localStorage) {
		var nameContainer = 'settings';
		{ // settings beginning with gtgt go into separate container
			var gt = unescape('%3E');
			if (prefKey.substr(0, 2) == gt+gt) {
				nameContainer = 'voted';
			}
		}
		var currentPrefs = localStorage.getItem(nameContainer);

		var prefsObj;
		if (currentPrefs) {
			prefsObj = JSON.parse(currentPrefs);
		} else {
			prefsObj = Object();
		}
		var prefValue = prefsObj[prefKey];

		if (!prefValue && prefValue != 0) {
			// these settings default to 1/true:
			if (
				prefKey == 'beginner' ||
				prefKey == 'beginner_highlight' ||
				prefKey == 'notify_on_change'
			) {
				prefValue = 1;
			}
			if (
				prefKey == 'show_advanced' ||
				prefKey == 'show_admin' ||
				prefKey == 'draggable'
			) {
				prefValue = 0;
			}
		}

		SetPrefs(prefKey, prefValue);

		return prefValue;
	}

	//alert('debug: GetPrefs: fallthrough, returning false');
	return false;
} // GetPrefs()

function SetPrefs (prefKey, prefValue) { // set prefs key prefKey to value prefValue
    //alert('DEBUG: SetPrefs(' + prefKey + ', ' + prefValue + ')');

	if (prefKey == 'show_advanced' || prefKey == 'beginner' || prefKey == 'show_admin') {
		//alert('DEBUG: SetPrefs: setting cookie to match LocalStorage');
		if (window.SetCookie) {
			SetCookie(prefKey, (prefValue ? 1 : 0));
		}
	}

	if (window.localStorage) {
		var nameContainer = 'settings';
		var gt = unescape('%3E');
		if (prefKey.substr(0, 2) == gt+gt) {
			nameContainer = 'voted';
		}

		var currentPrefs = localStorage.getItem(nameContainer);
		var prefsObj;
		if (currentPrefs) {
			prefsObj = JSON.parse(currentPrefs);
		} else {
			prefsObj = Object();
		}
		prefsObj[prefKey] = prefValue;

		var newPrefsString = JSON.stringify(prefsObj);
		localStorage.setItem(nameContainer, newPrefsString);
		return 0;
	}

	return 1;
}

function SaveCheckbox (ths, prefKey) { // saves value of checkbox, toggles affected elements
// id = id of pane to hide or show; not required
// ths = "this" of calling checkbox)
// prefKey = key of preference value to set with checkbox
//
// this function is a bit of a mess, could use a refactor #todo

	//alert('DEBUG: SaveCheckbox(' + ths + ',' + prefKey);

	var checkboxState = (ths.checked ? 1 : 0);
	//alert('DEBUG: checkboxState = ' + checkboxState);

	// saves checkbox's value as 0/1 value to prefs(prefKey)
	SetPrefs(prefKey, (ths.checked ? 1 : 0));


	if (prefKey == 'draggable') {
		if (ths.checked) {
			DraggingInit(0);
		} else {
			//#todo
		}
	}

	//alert('DEBUG: after SetPrefs, GetPrefs(' + prefKey + ') returns: ' + GetPrefs(prefKey));

	// call ShowAdvanced(1) to update ui appearance
	// ShowAdvanced(1);

	return 1;
}

function SetInterfaceMode (ab) { // updates several settings to change to "ui mode" (beginner, advanced, etc.)
    //alert('DEBUG: SetInterfaceMode(' + ab + ')');

	if (window.localStorage && window.SetPrefs) {
		if (ab == 'beginner') {
			SetPrefs('show_advanced', 0);
			SetPrefs('advanced_highlight', 0);
			SetPrefs('beginner', 1);
			SetPrefs('beginner_highlight', 1);
			SetPrefs('notify_on_change', 1);
			SetPrefs('show_admin', 0);
			SetPrefs('write_enhance', 0);
			SetPrefs('write_autosave', 0);
			SetPrefs('expert_timestamps', 0);
			SetPrefs('draggable', 0);
//			SetPrefs('sign_by_default', 1);
		} else if (ab == 'intermediate') {
			SetPrefs('show_advanced', 1);
			SetPrefs('advanced_highlight', 1);
			SetPrefs('beginner', 1);
			SetPrefs('beginner_highlight', 1);
			SetPrefs('notify_on_change', 1);
//            SetPrefs('show_admin', 0);
		} else if (ab == 'expert') {
			SetPrefs('show_advanced', 1);
			SetPrefs('advanced_highlight', 0);
			SetPrefs('beginner', 0);
			SetPrefs('beginner_highlight', 0);
			SetPrefs('notify_on_change', 1);
//            SetPrefs('show_admin', 0);
// 		} else if (ab == 'minimal') {
// 			SetPrefs('show_advanced', 0);
// 			SetPrefs('advanced_highlight', 0);
// 			SetPrefs('beginner', 0);
// 			SetPrefs('beginner_highlight', 0);
// 			SetPrefs('notify_on_change', 0);
// //            SetPrefs('show_admin', 0);
// 		} else if (ab == 'operator') {
//             SetPrefs('show_admin', 1);
		}

		ShowAdvanced(1);

        //alert('DEBUG: window.SetPrefs was found, and ShowAdvanced(1) was called');

		return false;
	}

	//alert('DEBUG: returning true');

	return true;
}


function LoadCheckbox (c, prefKey) { // updates checkbox state to reflect settings
// c = checkbox
// prefKey = key of preference value
//
	//alert('DEBUG: LoadCheckbox(' + c + ',' + prefKey);
	var checkboxState = GetPrefs(prefKey);
	//alert('DEBUG: checkboxState = ' + checkboxState);

	if (c && c.checked != (checkboxState ? 1 : 0)) {
		c.checked = (checkboxState ? 1 : 0);
	}

	return 1;
}


function SettingsOnload () { // onload function for settings page
	//alert('debug: SettingsOnload() begin');

	if (document.getElementById) {
	// below is code which sets the checked state of settings checkboxes
	// based on settings state
		var pane;

		//LoadCheckbox(document.getElementById('chkSignByDefault'), 'sign_by_default');
		LoadCheckbox(document.getElementById('chkDraggable'), 'draggable');
		LoadCheckbox(document.getElementById('chkShowAdmin'), 'show_admin');
		LoadCheckbox(document.getElementById('chkShowAdvanced'), 'show_advanced');
		LoadCheckbox(document.getElementById('chkWriteEnhance'), 'write_enhance');
		LoadCheckbox(document.getElementById('chkWriteEnhance'), 'write_enhance');
		LoadCheckbox(document.getElementById('chkExpertTimestamps'), 'expert_timestamps');

		//if (GetPrefs('sign_by_default') == 1) {
		//	var cbM = document.getElementById('chkSignByDefault');
		//	if (cbM) {
		//		cbM.checked = 1;
		//	}
		//}

	}

	//alert('debug: SettingsOnload: returning false');
	return false;
} // SettingsOnload()

if (window.EventLoop) {
	window.eventLoopShowAdvanced = 1;
} else {
	ShowAdvanced();
}

// == end settings.js


// == begin avatar.js

function setAva () { // sets avatar widgets (and italicizes Profile link)
	//alert('DEBUG: setAva() begins');
	
	if (document.getElementById && String.fromCharCode) {
		var myidBox = document.getElementById('myid'); // displays username (if preference is set)
		var signinBox = document.getElementById('signin'); // Profile link

		var gt = String.fromCharCode(62);

		if (myidBox && signinBox && window.localStorage) { // check for elements and features
			var myAvatar = localStorage.getItem('avatar');

			if (!myAvatar) { // less error prone than checking for ==n ull, i think
				signinBox.innerHTML = '<a href="/profile.html"' + gt + 'Profile</a' + gt + '';
			} else {
				signinBox.innerHTML = '';
				var myFp = localStorage.getItem('fingerprint');

				if (window.location.pathname == '/author/' + myFp + '/' || window.location.pathname == '/author/' + myFp + '/index.html') {
					var itsYou = document.getElementById('itsyou');
					itsYou.innerHTML = 'This is your profile!';
				}

				if (window.GetPrefs) {
					if (GetPrefs('display_username')) {
						myidBox.innerHTML = '<a href="/profile.html" class=avatar' + gt + myAvatar + '</a' + gt;
						signinBox.innerHTML = '';
					} else {
						myidBox.innerHTML = '';
						signinBox.innerHTML = '<a href="/profile.html"' + gt + '<i' + gt + 'Profile</i' + gt + '</a' + gt + '';
					}
				} else {
					myidBox.innerHTML = '';
					signinBox.innerHTML = '<a href="/profile.html"' + gt + '<i' + gt + 'Profile</i' + gt + '</a' + gt + '';
				}

				if (!window.openpgp && document.head && document.getElementById && window.localStorage) {
					//alert('DEBUG: setAva: loading openpgp.js');
					window.openPgpJsLoadBegin = 1;

					var script = document.createElement('script');
					script.src = '/openpgp.js';
					script.async = false; // This is required for synchronous execution
					document.head.appendChild(script);
				}

				if (!window.setAvatar && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
					//alert('DEBUG: setAva: loading crypto2.js');

					var script2 = document.createElement('script');
					script2.src = '/crypto2.js';
					script2.async = false; // This is required for synchronous execution
					document.head.appendChild(script2);
				}
			}
		}
	}

	return true;
} // setAva()
if (window.localStorage && document.getElementById) {
	setAva();
}

function getAvatar () { // retrieve previously built avatar from localStorage (already in html form)
	if (window.localStorage) {
		var myAvatar = localStorage.getItem("avatar");
		if (!myAvatar || myAvatar.length == 0) {
			return '';
		} else {
			return myAvatar;
		}
	} else {
		return 'Anonymous*';
	}

	return false;
} // getAvatar()

// == end avatar.js


// == begin voting.js

function PingUrlCallback () {
	var xmlhttp = window.xmlhttp;

	if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
		//alert('DEBUG: PingUrlCallback() found status 200');

//		window.location.replace(xmlhttp.responseURL);
//		document.open();
//		document.write(xmlhttp.responseText);
//		document.close();
	}
}

function PingUrl (url) { // loads arbitrary url via image or xhr
// compatible with most js
	//alert('DEBUG: PingUrl() begins');

	// another option below
	// var img = document.createElement('img');
    // img.setAttribute("src", url);
    // document.body.appendChild(img);

	if (window.XMLHttpRequest) {
		//alert('DEBUG: PingUrl: window.XMLHttpRequest was true');

		var xmlhttp;
		if (window.xmlhttp) {
			xmlhttp = window.xmlhttp;
		} else {
			window.xmlhttp = new XMLHttpRequest();
			xmlhttp = window.xmlhttp;
		}

        xmlhttp.onreadystatechange = window.PingUrlCallback;

        xmlhttp.open("HEAD", url, true);
//		xmlhttp.timeout = 5000; //#xhr.timeout
        xmlhttp.send();

        return false;
	} else {
		//alert('DEBUG: PingUrl: using image method, no xhr here');

		if (document.images) {
			//alert('DEBUG: PingUrl: document.images was true');
			if (document.images.length) {
				// use last image on page, if possible. this should be the special pixel image.
				var img = document.images[document.images.length - 1];

				if (img) {
					img.setAttribute("src", url);

					return false;
				}
			} else {
				var img = document.images[0];

				if (img) {
					img.setAttribute("src", url);

					return false;
				}
			}
		}
	}

	return true;
}


//function OptionsDefault(token, privKeyObj) {
//	this.data = token;
//	this.privateKeys = [privKeyObj];
//}

function signCallback (signed) {
	var url = '/post.html?comment=' + encodeURIComponent(signed.data);

	if (PingUrl(url)) {
		// todo incrememnt counter
	}
}

function IncrementTagLink (t) { // increments number of votes in tag button
// adds a number if there isn't one already
// #todo adapt to accommodate buttons as well

	if (t.innerHTML) {
		// update count in vote link
		//alert('DEBUG: SignVote: t.innerHTML');
		var ih = t.innerHTML;
		if (ih.indexOf('(') == -1) {
			//alert('DEBUG: SignVote: ( not found');
			t.innerHTML = ih + '(1)';
		} else {
			//alert('DEBUG: SignVote: ( found');

			var numVal = ih.substring(ih.indexOf('(') + 1, ih.indexOf(')'));
			var newVal = parseInt(numVal) + 1;
			var hashTag = ih.substring(0, ih.indexOf('('));
			t.innerHTML = hashTag + '(' + newVal + ')';
		}
		//alert('DEBUG: SignVote: finished with t.innerHTML');
	}
}

function SignVote (t, token) { // signs a vote from referenced vote button
// t = reference to calling button's 'this'
// token = full voting token, in the format (gt)(gt)fileHash\n#tag
// where (gt) is a greater-than sign, omitted here
	//alert('DEBUG: SignVote(' + t + ',' + token +')');

	if (document.getElementById && window.getPrivateKey) {
	// basic dumb feature check #todo make smarter feature check ;
	// needs better compatibility for older browsers
		// get private key

		if (GetPrefs(token)) {
			// don't let user vote twice basic
			if (window.displayNotification) {
				window.duplicateVoteTries ? window.duplicateVoteTries++ : window.duplicateVoteTries = 1;
				if (3 <= window.duplicateVoteTries) {
					displayNotification('Hey!', t);
				} else {
					displayNotification('Already voted', t);
				}
			} else {
				//alert('DEBUG: window.displayNotification() was missing');
			}

			// returning false will keep the link from navigating to non-js fallback
			return false;
		}

		IncrementTagLink(t);

		var privkey = getPrivateKey();
		//alert('DEBUG: SignVote: privkey: ' + !!privkey);

		if (!privkey) {
			//alert('DEBUG: !privkey');
			// if there is no private key, just do a basic unsigned vote;

			if (PingUrl(t.href)) {
				// todo increment counter
			}
		} else {
			// there is a private key
			//alert('DEBUG: privkey is true');

			// load the private key into openpgp
			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
			var options;
			options = new Object();
			options.data = token;
			options.privateKeys = privKeyObj;
			openpgp.config.show_version = false;
			openpgp.config.show_comment = false;

			// sign the voting token and send to post.html when finished
			openpgp.sign(options).then(signCallback);
		}

		// remember that we voted for this already
		SetPrefs(token, 1);


		if (window.displayNotification) {
			//displayNotification('Success!', t);
		} else {
			//alert('DEBUG: window.displayNotification() was missing');
		}

		return false; // cancel link click-through
	} else {
		//	    if (document.images) {
		//	        var myUrl = window.location;
		//	    	document.images[0].src = '/post.html?mydomain=' + myUrl;
		//
		//	    	//alert('DEBUG: t = ' + t);
		//
		//	    	return false;
		//	    }
	}

	return true; // allow link click to happen
}

// == end voting.js


// == begin utils.js

// begin html escape hack (credit stacko)
// only works with createElement #backlog
if (document.createElement) {
	var escapeTA = document.createElement('textarea');
}
function escapeHTML(html) {
	if (window.escapeTA) {
		escapeTA.textContent = html;
		return escapeTA.innerHTML;
	}
}
function unescapeHTML(html) {
	if (window.escapeTA) {
		escapeTA.innerHTML = html;
		return escapeTA.textContent;
	}
}
// end html escape hack

function OnLoadEverything () { // checks for each onLoad function and calls it
// keywords: OnLoadAll BodyOnLoad body onload body.onload
// typically called from body.onload
	//alert('DEBUG: OnLoadEverything() begins');

	if (window.setClock) {
		//alert('DEBUG: OnLoadEverything: setClock()');
		window.eventLoopSetClock = 1;
		setClock();
	}
	if (window.ItsYou) {
		//alert('DEBUG: OnLoadEverything: ItsYou()');
		ItsYou();
	}
	if (window.ShowTimestamps) {
		//alert('DEBUG: OnLoadEverything: ShowTimestamps()');
		window.eventLoopShowTimestamps = 1;
	}
	if (window.SettingsOnload) {
		//alert('DEBUG: OnLoadEverything: SettingsOnload()');
		SettingsOnload();
	}
	if (window.ProfileOnLoad) {
		//alert('DEBUG: OnLoadEverything: ProfileOnLoad()');
		ProfileOnLoad();
	}
	if (window.WriteOnload) {
		//alert('DEBUG: OnLoadEverything: WriteOnload()');
		WriteOnload();
	}
	if (window.ShowAdvanced) {
		//alert('DEBUG: OnLoadEverything: ShowAdvanced()');
		window.eventLoopShowAdvanced = 1;
		ShowAdvanced(0);
	}
	if (window.SearchOnload) {
		//alert('DEBUG: OnLoadEverything: SearchOnload()');
		SearchOnload();
	}
	if (window.UploadAddImagePreviewElement) {
		//alert('DEBUG: OnLoadEverything: UploadAddImagePreviewElement()');
		UploadAddImagePreviewElement();
	}
	if (
		(
			window.location.href &&
			window.location.href.indexOf('write') != -1 ||
			window.location.hash.indexOf('reply') != -1
		) &&
		document.compose &&
		document.compose.comment &&
		document.compose.comment.focus
	) {
		//alert('DEBUG: OnLoadEverything: document.compose.comment.focus()()');
		document.compose.comment.focus();
	}
	if (window.location.href && (window.location.href.indexOf('search') != -1) && document.search.q) {
		//alert('DEBUG: OnLoadEverything: document.search.q.focus()');
		document.search.q.focus();
	}
//	if (window.DraggingInit && GetPrefs('draggable')) {
	if (window.DraggingInit) {
		//alert('DEBUG: OnLoadEverything: DraggingInit()');
		if (window.location.href.indexOf('desktop') != -1) {
			DraggingInit(1);
		} else {
			DraggingInit(0);
		}
	}
	if (window.EventLoop) {
		//alert('DEBUG: OnLoadEverything: EventLoop()');
		if (window.CheckIfFresh) {
			window.eventLoopFresh = 1;
		}
		window.eventLoopEnabled = 1
		EventLoop();
	}
	if (window.HideLoadingIndicator) {
		//alert('DEBUG: OnLoadEverything: HideLoadingIndicator()');
		HideLoadingIndicator();
	}

	// everything is set now, start event loop
	//
} // OnLoadEverything()

function ShowPreNavigateNotification () {
	//alert('DEBUG: ShowPreNavigateNotification() begin');
	document.title = 'Meditate...';
	//document.body.style.opacity="0.8";

	if (document.getElementById) {
		var ariaAlert;
		ariaAlert = document.getElementById('ariaAlert');

		if (!ariaAlert) {
			ariaAlert = document.createElement('p');
			ariaAlert.setAttribute('role', 'alert');
			ariaAlert.setAttribute('id', 'ariaAlert');
			ariaAlert.innerHTML = 'Meditate...';
			ariaAlert.style.opacity = '1';
			ariaAlert.style.zIndex = '1337';
			//document.body.appendChild(ariaAlert);
			document.body.insertBefore(ariaAlert, document.body.firstChild);
		}
	}

	return ''; // true would show a confirmation
}

function EventLoop () { // for calling things which need to happen on a regular basis
// sets another timeout for itself when done
// replaces several independent timeouts
// #backlog add secondary EventLoopWatcher timer which ensures this one runs when needed

	var d = new Date();
	var eventLoopBegin = d.getTime();

	//alert('DEBUG: EventLoop: eventLoopBegin = ' + eventLoopBegin + ' - window.eventLoopPrevious = ' + window.eventLoopPrevious + ' = ' + (eventLoopBegin - window.eventLoopPrevious));

	if (!window.eventLoopPrevious) {
		window.eventLoopPrevious = 1;
	}

	if (window.eventLoopSetClock && window.setClock) {
		setClock();
	}

	if (10000 < (eventLoopBegin - window.eventLoopPrevious)) {
		window.eventLoopPrevious = eventLoopBegin;

		if (window.flagUnloaded) {
			if (window.ShowPreNavigateNotification) {
				ShowPreNavigateNotification();
			}
		}

		//return;
		// uncomment to disable event loop
		// makes js debugging easier

		if (window.eventLoopShowTimestamps && window.ShowTimestamps) {
			if (13000 < (eventLoopBegin - window.eventLoopShowTimestamps)) {
				ShowTimestamps();
				window.eventLoopShowTimestamps = eventLoopBegin;
			} else {
				// do nothing
			}
		}

		if (window.eventLoopDoAutoSave && window.DoAutoSave) {
			if (5000 < (eventLoopBegin - window.eventLoopDoAutoSave)) { // autosave interval
				DoAutoSave();
				window.eventLoopDoAutoSave = eventLoopBegin;
			} else {
				// do nothing
			}
		}

		if (window.eventLoopShowAdvanced && window.ShowAdvanced) {
			ShowAdvanced();
		}

		if (window.eventLoopFresh && window.CheckIfFresh) {
			if (10000 < (eventLoopBegin - window.eventLoopFresh)) {
				//window.eventLoopFresh = eventLoopBegin;
				if (GetPrefs('notify_on_change')) {
					CheckIfFresh();
				}
				window.eventLoopFresh = eventLoopBegin;
			}
		}
	} // 10000 < (eventLoopBegin - window.eventLoopPrevious)

	if (window.eventLoopEnabled) {
		var d = new Date();
		var eventLoopEnd = d.getTime();
		var eventLoopDuration = eventLoopEnd - eventLoopBegin;
		//document.title = eventLoopDuration; // for debugging performance

		if (window.timeoutEventLoop) {
			clearTimeout(window.timeoutEventLoop);
		}

		if (100 < eventLoopDuration) {
			// if loop went longer than 100ms, run every 3 seconds or more
			eventLoopDuration = eventLoopDuration * 30;
		} else {
			// otherwise run every 1 second
			eventLoopDuration = 1000;
		}
		//document.title = eventLoopDuration; // for debugging performance

		window.timeoutEventLoop = setTimeout('EventLoop()', eventLoopDuration);
	} // window.eventLoopEnabled

} // EventLoop()

function UrlExists(url) { // checks if url exists
// todo use async
// todo how to do pre-xhr browsers?
    //alert('DEBUG: UrlExists(' + url + ')');

	if (window.XMLHttpRequest) {
	    //alert('DEBUG: UrlExists: window.XMLHttpRequest check passed');

		var http = new XMLHttpRequest();
		http.open('HEAD', url, false);
		//http.timeout = 5000; //#xhr.timeout
		http.send();
		var httpStatusReturned = http.status;

		//alert('DEBUG: UrlExists: httpStatusReturned = ' + httpStatusReturned);

		return (httpStatusReturned == 200);
	}
}
//
//function UrlExists2(url, callback) { // checks if url exists
//// todo use async and callback
//// todo how to do pre-xhr browsers?
//    //alert('DEBUG: UrlExists(' + url + ')');
//
//	if (window.XMLHttpRequest) {
//	    //alert('DEBUG: UrlExists: window.XMLHttpRequest check passed');
//
//        var xhttp = new XMLHttpRequest();
//        xhttp.onreadystatechange = function() {
//    if (this.readyState == 4 && this.status == 200) {
//       // Typical action to be performed when the document is ready:
//       document.getElementById("demo").innerHTML = xhttp.responseText;
//    }
//};
//xhttp.open("GET", "filename", true);
//xhttp.send();
//
//
//
//		var http = new XMLHttpRequest();
//		http.open('HEAD', url, false);
//		http.send();
//		var httpStatusReturned = http.status;
//
//		//alert('DEBUG: UrlExists: httpStatusReturned = ' + httpStatusReturned);
//
//		return (httpStatusReturned == 200);
//	}
//}

function DisplayStatus(status) {
	if (document.getElementById) {
		var statusBar = document.getElementById('status');

	}
}

function DownloadAsTxt(filename, text) {
    var element = document.createElement('a');

    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}


function displayNotification (strMessage, thisButton) { // adds notificatin to page
// used for loading indicator bar (to top of page, depending on style)
// also used for "creating profile" and "already voted" notifications
	var spanNotification = document.createElement('span');
	spanNotification.setAttribute('class', 'notification');
	spanNotification.setAttribute('role', 'alert');
	spanNotification.setAttribute('onclick', 'if (this.remove) { this.remove() } return false;');
	spanNotification.innerHTML = strMessage;

	if (thisButton) {
		thisButton.parentNode.appendChild(spanNotification);
		thisButton.after(spanNotification);
	} else {
		document.body.appendChild(spanNotification);
	}
} // displayNotification()

function newA (href, target, innerHTML, parent) { // makes new a element and appends to parent
	var newLink = document.createElement('a');
	if (href) { newLink.setAttribute('href', href); }
	if (target) { newLink.setAttribute('target', target); }
	if (innerHTML) { innernewLink.setAttribute('innerHTML', innerHTML); }
	parent.appendChild(newLink);
	return newLink;
}

function CollapseWin (t) { // collapses or expands window based on t's caption
// t is presumed to be clicked element's this, but can be any other element
// if t's caption is 'v', window is re-expanded
// if 'x' (or anything else) collapses window
// this is done by navigating up until a table is reached
// and then hiding the first class=content element within
// presumably a TR but doesn't matter really because SetElementVisible() is used
// pretty basic, but it works.
	if (t.innerHTML && t.firstChild) {
		if (t.firstChild.nodeName == 'FONT') {
			// small hack in case link has a font tag inside
			// the font tag is typically used to style the link a different color for older browsers
			t = t.firstChild;
		}
		var newVisible = 'initial';
		if (t.innerHTML == '}-{') { //#collapseButton
			t.innerHTML = '{-}'; // //#collapseButton
		} else {
			t.innerHTML = '}-{'; //#collapseButton
			newVisible = 'none';
		}
		if (t.parentElement) {
			var p = t;
			while (p.nodeName != 'TABLE') {
				p = p.parentElement;
				if (p.getElementsByClassName) {
					var content = p.getElementsByClassName('content');
					if (content.length) {
						SetElementVisible(content[0], newVisible);
						return false;
					}
				}
			}
		}
	}
	return true;
} // CollapseWin()

//function ChangeInputToTextarea (input) { // called by onpaste
////#input_expand_into_textarea
//	//#todo more sanity
//	if (!input) {
//		return '';
//	}
//
//	if (document.createElement) {
//		var parent = input.parentElement;
//		var textarea = document.createElement('textarea');
//		var cols = input.getAttribute('cols');
//		var name = input.getAttribute('name');
//		var id = input.getAttribute('id');
//		var rows = 5;
//		var width = cols + 'em';
//
//		textarea.setAttribute('name', name);
//		textarea.setAttribute('id', id);
//		textarea.setAttribute('cols', cols);
//		textarea.setAttribute('rows', rows);
//		//textarea.style.width = width;
//		textarea.innerHTML = input.value;
//
//		//parent.appendChild(t);
//		parent.insertBefore(textarea, input.nextSibling);
//		input.style.display = 'none';
//
//		textarea.focus();
//		textarea.selectionStart = textarea.innerHTML.length;
//		textarea.selectionEnd = textarea.innerHTML.length;
//
//		if (window.inputToChange) {
//			window.inputToChange = '';
//		}
//	}
//
//	return true;
//}

//
//function ConvertSubmitsToButtonsWithAccessKey (parent) {
//	if (!parent) {
//		//alert('DEBUG: ConvertSubmitsToButtons: warning: sanity check failed');
//		return '';
//	}
//
//	if (parent.getElementsByClassName) {
//		var buttons = parent.getElementsByClassName('btnSubmit');
//		// convert each submit to button with accesskey
//	} else {
//		//todo
//	}
//	return ''
//} // ConvertSubmitsToButtonsWithAccessKey()

// == end utils.js


// begin profile.js

if (!window.openpgp && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
	//alert('DEBUG: loading openpgp.js');
	window.openPgpJsLoadBegin = 1;

	var script = document.createElement('script');
	script.src = '/openpgp.js';
	script.async = false; // This is required for synchronous execution
	document.head.appendChild(script);
	//alert('DEBUG: finished loading openpgp.js; window.openpgp: ' + !!window.openpgp);
} else {
	//alert('DEBUG: not loading openpgp.js; window.openpgp: ' + !!window.openpgp + ' document.getElementById: ' + !!document.getElementById + ' window.localStorage: ' + !!window.localStorage + ' window.Promise: ' + !!window.Promise);
}

if (!(window.MakeKey) && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
	//alert('DEBUG: loading crypto2.js');

	var script2 = document.createElement('script');
	script2.src = '/crypto2.js';
	script2.async = false; // This is required for synchronous execution
	document.head.appendChild(script2);

	//alert('DEBUG: finished loading crypto2.js; window.cryptoJs: ' + !!window.cryptoJs + '; document.getPrivateKey: ' + !!document.getPrivateKey + '; window.openpgp: ' + !!window.openpgp);
} else {
	//alert('DEBUG: not loading crypto2.js; ' + ' window.MakeKey = ' + window.MakeKey + '; document.getElementById = ' + document.getElementById + ' window.localStorage = ' + window.localStorage );
}

function btnSignOut_Click(t) { // event for 'Sign Out' button's click
	//alert('DEBUG: btnSignOut_Click begin');

	if (window.localStorage) {
		//alert('DEBUG: localStorage is true');

		var ls = window.localStorage;
		ls.removeItem('privatekey');
		ls.removeItem('publickey');
		ls.removeItem('fingerprint');
		ls.removeItem('avatar');
		ls.removeItem('settings');
		ls.removeItem('voted');

		SetPrefs('last_pubkey_ping', 0);
	}

	return true;
}

function btnRegister_Click (t) { // event for 'Register' button's click
// t is clicked button's "this" object
	//alert('DEBUG: btnRegister_Click() begin');
	if (t) {
		if (t.value) {
			t.value = 'Meditate...';
		}
	}

	//if (window.localStorage && window.Promise) { // this extra check is disabled for some reason, I think IE?
	if (window.localStorage && document.getElementById) {
		//alert('DEBUG: btnRegister_Click: localStorage and Promise feature check pass');
		if (window.MakeKey) {
			//alert('DEBUG: btnRegister_Click: window.MakeKey exists, calling MakeKey()');

			var chkEnablePGP = document.getElementById('chkEnablePGP');
			if (chkEnablePGP && chkEnablePGP.checked) {
				//alert('DEBUG: chkEnablePGP is present and checked');
				var intKeyGenResult = MakeKey(t);
				//alert('DEBUG: btnRegister_Click: intKeyGenResult = ' + intKeyGenResult);
				SetPrefs('last_pubkey_ping', 1);
				//alert('DEBUG: returning intKeyGenResult = ' + intKeyGenResult);
				return intKeyGenResult;
			}
		}
	} else {
		return true;
	}

	return true;
}

function getUserFp () { // retrieve stored user fingerprint from LocalStorage
	//alert('DEBUG: getUserFp() begin');

	if (window.localStorage) {
		// LocalStorage mode
		var fingerprint = localStorage.getItem('fingerprint');
		if (fingerprint) {
			return fingerprint;
		}
	} else {
		// fallback to cookie mode
		var fingerprint = GetCookie('cookie');

		if (fingerprint) {
			return fingerprint;
		}
	}

	// nothing found, we looked everywhere
	return '';
}

function sharePubKey (t) { // shares current user's public key via injected form and iframe
	//alert('DEBUG: profile.js: sharePubKey() begins');

	if (window.getPublicKey) {
		var pubKey = getPublicKey();

		//alert('DEBUG: sharePubKey: pubKey = ' + (pubKey ? pubKey : '(false)'));

		if (pubKey) {
			if (window.displayNotification) {
				if (t) {
					displayNotification('Creating profile...', t);
				} else {
					// #todo this appears at the bottom of the page
					// probably not visible to most users
					// so the redirect is a surprise
					displayNotification('Creating profile...');
				}
			}

			//alert('DEBUG: sharePubKey: creating form');

			var form = document.createElement('form');
			form.setAttribute("action", "/post.html");
			form.setAttribute("method", "get");
			//form.setAttribute("target", "ifrSharePubKey");

			//alert('DEBUG: sharePubKey: creating input');

			var txtComment = document.createElement('input');
			txtComment.setAttribute("type", "hidden");
			txtComment.setAttribute("value", pubKey);
			txtComment.setAttribute("name", "comment");

			//alert('DEBUG: sharePubKey: adding txtComment to form');

			form.appendChild(txtComment);

			//alert('DEBUG: sharePubKey: adding form to body');

			//document.getElementsByTagName('body')[0].appendChild(form);

			document.body.appendChild(form);

			//alert('DEBUG: submitting form');

			form.submit();

			return false;
		} else {
			//alert('DEBUG: pubKey was FALSE');

			return true;
		}
	}

///// alternative method 1
//	window.open('/write.html#inspubkey', '_self');

///// alternative method 2
//	var iframe = document.createElement("iframe");
//	iframe.src = '/write.html#inspubkey';
//	iframe.name = "inspubkey"
//	iframe.style.display = 'none';
//	document.body.appendChild(iframe);

	return true;
}

function AddPrivateKeyLinks () { // adds save/load links to profile page if features are available
// #todo make it so that this can be called repeatedly and hide/show appropriate links
// this will allow to avoid having to reload profile page on status change

	//alert('DEBUG: AddPrivateKeyLinks() begin');
	if (document.getElementById && window.getPrivateKey) {
		//alert('DEBUG: AddPrivateKeyLinks: document.getElementById && window.getPrivateKey');
		var privateKey = getPrivateKey();
		var fieldset = document.getElementById('fldRegistration');

		if (fieldset && document.createElement) {
			//alert('DEBUG: AddPrivateKeyLinks: fieldset && document.createElement');

			if (privateKey) {
				//alert('DEBUG: AddPrivateKeyLinks: privateKey: true');

				// hr
				var hrDivider = document.createElement('hr');
				fieldset.appendChild(hrDivider);

				// [go to profile]
				var pProfileLink = document.getElementById('spanProfileLink');
				if (pProfileLink && pProfileLink.innerHTML) {
					// profile link already there, and contains profile link
					// #todo bind js event to profile create
				} else {
					// profile link not there or the p is empty
					if (!pProfileLink) {
						pProfileLink = document.createElement('p');
					}

					// ATTENTION!
					// THERE IS A GOTCHA HERE: THIS LINK MAY ALSO BE
					// ADDED BY PHP; THEN THIS CODE WILL NOT EXECUTE!
					// BECAUSE pProfileLink WILL ALREADY BE TRUE ABOVE

					// "Go to profile" link
					var aProfile = document.createElement('a');
					aProfile.setAttribute('href', '/author/' + getUserFp() + '/index.html');
					aProfile.setAttribute('onclick', 'if (window.sharePubKey) { return sharePubKey(this); }');
					aProfile.setAttribute('id', 'linkGoToProfile');
					aProfile.innerHTML = 'Go to profile';

					// Append both to fieldset
					pProfileLink.appendChild(aProfile);
					fieldset.appendChild(pProfileLink);

					// add horizontal rule
					var hrDivider = document.createElement('hr');
					fieldset.appendChild(hrDivider);
				}

				// [save as file]
				var pSaveKeyAsTxt = document.createElement('p');
				var aSaveKeyAsTxt = document.createElement('a');
				aSaveKeyAsTxt.setAttribute('href', '#');
				aSaveKeyAsTxt.setAttribute('id', 'linkSavePrivateKey');
				aSaveKeyAsTxt.setAttribute('onclick', 'if (window.SavePrivateKeyAsTxt) { return SavePrivateKeyAsTxt(); }');
				aSaveKeyAsTxt.innerHTML = 'Save as file';

				// hint for [save as file]
				var hintSaveKeyAsTxt = document.createElement('span');
				hintSaveKeyAsTxt.setAttribute('class', 'beginner');
				hintSaveKeyAsTxt.innerHTML = 'Save key to use again later';

				// insert [save as file] link into dom
				pSaveKeyAsTxt.appendChild(aSaveKeyAsTxt);
				var brSaveKeyAs = document.createElement('br');
				pSaveKeyAsTxt.appendChild(brSaveKeyAs);
				pSaveKeyAsTxt.appendChild(hintSaveKeyAsTxt);
				fieldset.appendChild(pSaveKeyAsTxt);

				// [show private key]
				var pShowPrivateKey = document.createElement('p');
				var aShowPrivateKey = document.createElement('a');
				pShowPrivateKey.setAttribute('class', 'advanced');
				
				aShowPrivateKey.setAttribute('href', '#');
				aShowPrivateKey.setAttribute('id', 'linkShowPrivateKey');
				aShowPrivateKey.setAttribute('onclick', 'if (window.ShowPrivateKey) { return ShowPrivateKey(); }');
				aShowPrivateKey.innerHTML = 'Show private key';
				
				// hint for [show private key]
				var hintShowPrivateKey = document.createElement('span');
				hintShowPrivateKey.setAttribute('class', 'beginner');
				hintShowPrivateKey.innerHTML = 'Display as text you can copy';

				pShowPrivateKey.appendChild(aShowPrivateKey);
				brElement = document.createElement('br');
				pShowPrivateKey.appendChild(brElement);
				pShowPrivateKey.appendChild(hintShowPrivateKey);
				fieldset.appendChild(pShowPrivateKey);
			} // privateKey is true
			else {
				//alert('DEBUG: AddPrivateKeyLinks: privateKey: false');

				// add horizontal rule
				var hrDivider = document.createElement('hr');
				fieldset.appendChild(hrDivider);

				var pLoadKeyFromTxt = document.createElement('p');

				//alert('DEBUG: AddPrivateKeyLinks: creating file input...');

				var labelLoadFromFile = document.getElementById('fileLoadKeyFromText');
				if (!labelLoadFromFile) {
					// label for "load from file" button
					var labelLoadFromFile = document.createElement('label');
					labelLoadFromFile.setAttribute('for', 'fileLoadKeyFromText');
					labelLoadFromFile.innerHTML = 'Load from file:';

					// br after label
					var brLoadFromFile = document.createElement('br');
					labelLoadFromFile.appendChild(brLoadFromFile);

					// [load from file] file selector
					var fileLoadKeyFromText = document.createElement('input');
					fileLoadKeyFromText.setAttribute('type', 'file');
					fileLoadKeyFromText.setAttribute('accept', 'text/plain');
					fileLoadKeyFromText.setAttribute(
						'onchange',
						 'if (window.openFile) { openFile(event) } else { alert("i am so sorry, openFile() function was missing!"); }'
					);
					fileLoadKeyFromText.setAttribute('id', 'fileLoadKeyFromText');
					// fileLoadKeyFromText.setAttribute('style', 'display: none');
					// i tried hiding file selector and using a button instead.
					// it looked nicer, but sometimes didn't work as expected

					// hint for [load from file]
					var hintLoadFromFile = document.createElement('span');
					hintLoadFromFile.setAttribute('class', 'beginner');
					hintLoadFromFile.innerHTML = 'Use this if you have a saved key';


					// pLoadKeyFromTxt.appendChild(aLoadKeyFromText);
					labelLoadFromFile.appendChild(fileLoadKeyFromText);
					var brLoadFromFile2 = document.createElement('br');
					pLoadKeyFromTxt.appendChild(labelLoadFromFile);
					pLoadKeyFromTxt.appendChild(brLoadFromFile2);
					pLoadKeyFromTxt.appendChild(hintLoadFromFile);


					fieldset.appendChild(pLoadKeyFromTxt);
				}
			} // privateKey is FALSE

			if (window.ShowAdvanced) {
				ShowAdvanced(1);
			}
		} // if (fieldset && document.createElement)
		else {
			//alert('DEBUG: AddPrivateKeyLinks: checks FAILED (fieldset && document.createElement)');
		}
	} else {
		//alert('DEBUG: AddPrivateKeyLinks: checks FAILED (document.getElementById && window.getPrivateKey)');
	}

	return true;
} // AddPrivateKeyLinks()

function ShowPrivateKey() { // displays private key in textarea
	//alert('DEBUG: ShowPrivateKey() begin');
	if (document.getElementById) {
		//alert('DEBUG: ShowPrivateKey: document.getElementById is true');

		var txtPrivateKey = document.getElementById('txtPrivateKey');
		if (txtPrivateKey) {
			//alert('DEBUG: ShowPrivateKey: txtPrivateKey is true');

			if (txtPrivateKey.style.display == 'none') {
				//alert('DEBUG: style is none, set to block');
				txtPrivateKey.style.display = 'block';
			} else {
				//alert('DEBUG: style is block, set to none');
				txtPrivateKey.style.display = 'none';
			}

			var linkShowPrivateKey = document.getElementById('linkShowPrivateKey');
			if (linkShowPrivateKey) {
				if (txtPrivateKey.style.display == 'none') {
					linkShowPrivateKey.innerHTML = 'Show private key';
				} else {
					linkShowPrivateKey.innerHTML = 'Hide private key';
				}
			}

			return false;
		}
	}

	if (window.getPrivateKey) {
		var privateKey = getPrivateKey();
		if (privateKey && document.createElement) {
			var txtPrivKey = document.createElement('textarea');
			txtPrivKey.setAttribute('cols', 80);
			txtPrivKey.setAttribute('rows', 24);
			txtPrivKey.setAttribute('id', 'txtPrivateKey');
			txtPrivKey.innerHTML = privateKey;

			var fldRegistration = document.getElementById('fldRegistration');
			if (fldRegistration) {
				fldRegistration.appendChild(txtPrivKey);
			} else {
				document.body.appendChild(txtPrivKey);
			}

			var linkShowPrivateKey = document.getElementById('linkShowPrivateKey');
			if (linkShowPrivateKey) {
				linkShowPrivateKey.innerHTML = 'Hide private key';
			}

			txtPrivKey.focus();

			return false;
		}
	}

	return true;
}

function openFile (event) {
	//alert('DEBUG: openFile() begin');

	var input = event.target;

	if (window.FileReader) {
		reader = new FileReader();

		// this eval is for hiding the "=function(){}" syntax from incompatible browsers
		// they shouldn't try to execute it because they don't make it here due to other tests
		eval('reader.onload = function() { var text = reader.result; LoadPrivateKeyFromTxt(text); }');
		reader.readAsText(input.files[0]);
	}

	return true;
}

function LoadPrivateKeyFromTxt (text) {
	if (window.setPrivateKeyFromTxt) {
		setPrivateKeyFromTxt(text);
	}

	return true;
}

function StripToFilename (text) { // strips provided text to only filename-valid characters
	if (!text) return '';

	text = text.trim();

	if (!text) return '';

	var charsAllowed = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';

	for (var i = 0; i < text.length; i++) {
		if (-1 < charsAllowed.indexOf(text.substr(i, 1))) {
			// ok
		} else {
			text = text.substr(0, i) + '' + text.substr(i + 1);
			i = i - 1;
		}
	}

	return text;
}

function getUsername2 () { // returns pgp username
// can be optimized with caching, but would also need to be
// un-cached when it changes. at this time, caching seems
// like over-optimization here
    var openpgp = window.openpgp;
    if (openpgp) {
		// read it into pgp object
		var privKeyObj = openpgp.key.readArmored(getPrivateKey());
		// get the public key out of it
		var pubKeyObj = privKeyObj.keys[0].toPublic();
		var myUsername = pubKeyObj.users[0].userId.userid;
		return myUsername;
	}
	return '';
} // getUsername2()

function SavePrivateKeyAsTxt() { // initiates "download" of private key as text file
	var myFp = getUserFp();
	var myUsername = getUsername2();
	var text = getPrivateKey();

	myUsername = StripToFilename(myUsername);

	return DownloadAsTxt(myUsername + '_' + myFp + '.txt', text);
}

// override cookie if we have a profile in LocalStorage
if (document.cookie) {
	//alert('DEBUG: cookie=' + document.cookie);
} else {
	//alert('DEBUG: document.cookie missing');
	if (window.localStorage) {
		//alert('DEBUG: window.localStorage exists');
		var fp = localStorage.getItem('fingerprint');
		if (fp) {
			//alert('DEBUG: fp exists, setting cookie via js');
			document.cookie = 'test=' + fp;
		}
	}
}

function PubkeyCheckProfileExists(fp) { // PLACEHOLDER checks if profile exists
// PLACEHOLDER, ALWAYS RETURNS TRUE
	//alert('DEBUG: PubkeyCheckProfileExists() begin');

	//alert('DEBUG: PubkeyCheckProfileExists: fp = ' + fp);

	var profileUrl = '/author/' + fp + '/';

	//alert('DEBUG: profileUrl = ' + profileUrl);

	if (UrlExists(profileUrl)) {
		//alert('DEBUG: lastPubKeyPing: profile exists');
		return true;
	} else {
		//alert('DEBUG: lastPubKeyPing: profile NOT FOUND');
		return false;
	}

	return true;
}

function PubKeyPing () { // checks if user's public key is on server
// uploads it to server if it is missing
//
	//alert('DEBUG: PubKeyPing() begin');

	var lastPing = GetPrefs('last_pubkey_ping');

	if (lastPing && (time() < (lastPing + 3600))) {
		//alert('DEBUG: PubKeyPing: lastPing+10 = ' + (lastPing+10) + ' < time() = ' + time());
	} else {
		//alert('DEBUG: PubKeyPing: lastPing was false or stale, doing a check at ' + time());

		if (window.location.href.indexOf('profile') != -1 && window.getUserFp) {
			//alert('DEBUG; PubKeyPing: window.getUserFp check passed');

			var myFingerprint = getUserFp();

			//alert('DEBUG: PubKeyPing: myFingerprint = ' + myFingerprint);

			if (myFingerprint) {
				if (PubkeyCheckProfileExists(myFingerprint)) {
					//alert('DEBUG: PubKeyPing: profile already exists');
				} else {
					if (window.sharePubKey) {
						//alert('DEBUG: PubKeyPing: lastPing: window.sharePubKey check passed, doing it...');
						sharePubKey();

						lastPing = time();
						SetPrefs('last_pubkey_ping', lastPing);
					} else {
						//alert('DEBUG: PubKeyPing: lastPing: window.sharePubKey check FAILED');
					}
				}
			} else {
				//alert('DEBUG: PubKeyPing: myFingerprint: false');
			}

			//alert('DEBUG: PubKeyPing: lastPing check complete, saving time');
		} else {
			//alert('DEBUG: PubKeyPing: window.getUserFp check FAILED');
		}
	}

	return true;
} // PubKeyPing()

function ProfileOnLoad () { // onload event for profile page
	//alert('DEBUG: ProfileOnLoad() begin');

	if (document.getElementById) {
		//alert('DEBUG: ProfileOnLoad: document.getElementById check passed');

		var lblSigningIndicator = document.getElementById('lblSigningIndicator');

		if (window.getPrivateKey) {
			//alert('DEBUG: ProfileOnLoad: window.getPrivateKey check passed');

			if (window.localStorage) {
				//alert('DEBUG: ProfileOnLoad: window.localStorage check passed, calling getPrivateKey()...');

				var pk = getPrivateKey();

				if (pk) {
					//alert('DEBUG: ProfileOnLoad: pk = GetPrivateKey() = ' + !!pk);
					// span used to indicate whether openpgp signing is available
					if (lblSigningIndicator) {
						//alert('DEBUG: lblSigningIndicator TRUE');
						// display value of "algorithm" which openpgp gives us
						// in reality, this only give us rsa/not-rsa, and formatted poorly
						// there's the bit count and the actual algo for non-rsa which needs
						// to be displayed more nicely here
						var privKeyObj = openpgp.key.readArmored(pk);
						var pubKeyObj = privKeyObj.keys[0].toPublic();

						var myAlgo = pubKeyObj.primaryKey.algorithm.toString();
						if (myAlgo) {
							lblSigningIndicator.innerHTML = myAlgo;
						} else {
							lblSigningIndicator.innerHTML = 'Yes';
						}
						AddPrivateKeyLinks();
					} else {
						//alert('DEBUG: lblSigningIndicator FALSE');
					}


					lblHandle = document.getElementById('lblHandle');

					if (lblHandle) {
						var strHandle = localStorage.getItem('avatar');
						if (strHandle) {
							lblHandle.innerHTML = strHandle;
						}
					}

					lblFingerprint = document.getElementById('lblFingerprint');

					if (lblFingerprint) {
						var strFingerprint = localStorage.getItem('fingerprint');
						if (strFingerprint) {
							lblFingerprint.innerHTML = strFingerprint;
						}
					}

					//alert('DEBUG: ProfileOnLoad: calling PubKeyPing()');
					PubKeyPing();
				} // pk is true
				else {
					//alert('DEBUG: pk = false')
					if (lblSigningIndicator) {
						//alert('DEBUG: lblSigningIndicator check passed');
						if (window.openpgp) {
							// #todo why is window.openpgp false here??
							//alert('DEBUG: window.openpgp check passed, setting no (available)');

							lblSigningIndicator.innerHTML = '';

							var lblEnablePGP = document.createElement('label');
							var chkEnablePGP = document.createElement('input');
							var txtEnablePGP = document.createTextNode('PGP');

							chkEnablePGP.setAttribute('type', 'checkbox');
							chkEnablePGP.setAttribute('name', 'chkEnablePGP');
							chkEnablePGP.setAttribute('id', 'chkEnablePGP');

							lblEnablePGP.setAttribute('for', 'chkEnablePGP');

							lblEnablePGP.appendChild(chkEnablePGP);
							lblEnablePGP.appendChild(txtEnablePGP);
							lblSigningIndicator.appendChild(lblEnablePGP);

							AddPrivateKeyLinks();
						} else {
							//alert('DEBUG: warning: window.openpgp check FAILED');
							lblSigningIndicator.innerHTML = 'Nope';
						}
					} else {
						//alert('DEBUG: lblSigningIndicator check FAILED');
					}
					AddPrivateKeyLinks();
				}
			} else {
				//alert('DEBUG: ProfileOnLoad: window.localStorage check FAILED');
			}
		} else {
			//alert('debug: ProfileOnLoad: window.getPrivateKey check FAILED');
		}
	} else {
		//alert('DEBUG: ProfileOnLoad: document.getElementById check FAILED');
	}

	return true;
}

function SetCookie (cname, cvalue, exdays) { // set cookie
	var d = new Date();
	d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
	var expires = "expires="+d.toUTCString();
	document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
	var testSetCookie = GetCookie(cname);
	if (cvalue == testSetCookie) {
		return 1;
	} else {
		return 0;
	}
} // SetCookie()

function GetCookie (cname) { // get cookie value
	// in js, cookies are accessed via one long string of the form
	// key1=value1; key2=value2;
	// so we make an array, splitting the string using the ; separator
	var ca = document.cookie.split(';');

	// the value we are looking for will be prefixed with cname=
	var name = cname + "=";

	for(var i = 0; i < ca.length; i++) {
		// loop through ca array until we find prefix we are looking for
		var c = ca[i];
		while (c.charAt(0) == ' ') {
			// remove any spaces at beginning of string
			c = c.substring(1);
		}
		if (c.indexOf(name) == 0) {
			// if prefix matches, return value
			return c.substring(name.length, c.length);
		}
	}

	// at this point, nothing left to do but return empty string
	return "";
}

// end profile.js


// == begin write.js

function WriteOnload () { // onload handler for write page
	//alert('DEBUG: WriteOnload() begin');

	if (document.getElementById) {
	    //alert('DEBUG: WriteOnload: document.getElementById is true');
        if (window.GetPrefs) {
			//alert('DEBUG: window.GetPrefs = TRUE');
        	if (GetPrefs('write_enhance')) {
				//alert('DEBUG: write_enhance = TRUE');
				var comment = document.getElementById('comment');
				if (comment) {
					if (window.location.href.indexOf('write') != -1) {
						CommentMakeWp(comment);
					} else {
						comment.setAttribute('onfocus', 'CommentMakeWp(this)');
					}
				}
			} else {
				//alert('DEBUG: write_enhance = FALSE');
			}
		} else {
			//alert('DEBUG: window.GetPrefs = FALSE');
		}
        var pubKey = '';
        if (window.getPublicKey) {
        	//alert('DEBUG: window.getPublicKey exists');
        	pubKey = getPublicKey();
        }
        var privKey = '';
        if (window.getPrivateKey) {
            //alert('DEBUG: window.getPrivateKey exists');
            privKey = getPrivateKey();
        }
        if (privKey) {
            //alert('DEBUG: privKey was true, adding options...');
			if (document.getElementById('spanSignAs')) {
				var gt = unescape('%3E');
				if (window.getAvatar) {
					var spanSignAs = document.getElementById('spanSignAs');

					var lblSignAs = document.createElement('label');
					lblSignAs.setAttribute('for', 'chkSignAs');

					var chkSignAs = document.createElement('input');
					chkSignAs.setAttribute('name', 'chkSignAs');
					chkSignAs.setAttribute('id', 'chkSignAs');
					chkSignAs.setAttribute('type', 'checkbox');
					chkSignAs.setAttribute('checked', 1);
					// implied getElementById already been feature checked here
					//chkSignAs.setAttribute('onclick', "if (document.getElementById('btnSolvePuzzle')) { document.getElementById('btnSolvePuzzle').setAttribute('disabled', !chkSignAs.checked); }");
					// this checkbox being checked means signMessage() is called in writeSubmit()

					lblSignAs.innerHTML = 'Sign as ' + getAvatar();
					lblSignAs.appendChild(chkSignAs);
					spanSignAs.appendChild(lblSignAs);

					if (window.solvePuzzle) {
						var spanWriteAdvanced = document.getElementById('spanWriteAdvanced');
						if (spanWriteAdvanced && window.solvePuzzle) {
							var btnSolvePuzzle = document.createElement('input');
							btnSolvePuzzle.setAttribute('id', 'btnSolvePuzzle');
							btnSolvePuzzle.setAttribute('type', 'button');
							btnSolvePuzzle.setAttribute('value', 'Solve Puzzle');
							btnSolvePuzzle.setAttribute('onclick',	"if (window.solvePuzzle) { return solvePuzzle(this); } else { return true; }");
							spanWriteAdvanced.appendChild(btnSolvePuzzle);

							var br = document.createElement('br');
							spanWriteAdvanced.appendChild(br);

							var lblSolvePuzzle = document.createElement('span');
							lblSolvePuzzle.setAttribute('class', 'beginner');
							var gt = unescape('%3E');
							lblSolvePuzzle.innerHTML = 'Establish trust, takes time, requires signature.';
							spanWriteAdvanced.appendChild(lblSolvePuzzle);
						}
					} // window.solvePuzzle
				} // window.getAvatar
			} // document.getElementById('spanSignAs')
        }

        if (pubKey) {
            //alert('DEBUG: pubKey was true, calling PubKeyPing()');
            if (window.PubKeyPing) {
            	PubKeyPing();
            }
        }

        if (window.location.hash) {
            //alert('DEBUG: window.location.hash = ' + window.location.hash);
            if (window.location.hash == '#inspubkey') {
                //alert('DEBUG: #inspubkey found');
				if (pubKey) {
					//alert('DEBUG: pubKey is true, inserting it into comment');
					var comment = document.getElementById('comment');
					if (comment) {
						comment.value = pubKey;
					}
                } else {
                    //alert('DEBUG: pubKey was false, this is unexpected. Giving up.');
                }
            }
        }
    } // document.getElementById
    else {
        //alert('DEBUG: WriteOnload: document.getElementById was FALSE');
    }

    return true;
} // WriteOnload()

function CommentMakeWp (comment) { // makes editor textarea larger and gives it wp color scheme
// called when write_enhance is on
	if (comment) {
		comment.style.backgroundColor = '#000080';
		comment.style.color = 'ffffff';
		comment.style.width = '95%';
		comment.style.height = '50%';
		comment.style.padding = '1em';
		comment.setAttribute('cols', 80);
		comment.setAttribute('rows', 24);
	}

	return '';
} // CommentMakeWp()

function writeSubmit (t) { // called when user submits write form //signMessage (
	//alert('DEBUG: writeSubmit() begin');
	if (window.localStorage) {
		//alert('DEBUG: window.localStorage');
		if (window.ClearAutoSave) {
			ClearAutoSave();
		}
	} else {
		//alert('DEBUG: no window.localStorage');
	}

	if (window.getPrivateKey && window.signMessage) {
		//alert('DEBUG: window.getPrivateKey && window.signMessage test passed');
		if (getPrivateKey()) {
			//alert('DEBUG: getPrivateKey() is true, writeSubmit() Calling signMessage()');

			if (document.getElementById) {
				var chkSignAs = document.getElementById('chkSignAs');
				if (!chkSignAs || (chkSignAs && chkSignAs.checked)) {
					// if there's a "sign as" checkbox, it should be checked
					if (window.signMessage) {
						var signMessageResult = signMessage();
						if (!signMessageResult) {
							signMessageResult = 0;
						}
						// once the message is signed, callback will submit the form
						return false; // uncomment this for duplicate unsigned messages feature
					}
				} else {
					// user choose not to sign
					return true;
				}
			}
		} else {
			// no private key
			//alert('DEBUG: no private key, basic submit');
		}
	} else {
		//alert('DEBUG: Test Failed: window.getPrivateKey: ' + !!window.getPrivateKey + '; window.signMessage: ' + !!window.signMessage);
	}

	window.eventLoopFresh = 0; // disables fresh.js. may not be a wise move here.

	return true;
} // writeSubmit()

function DoAutoSave() {
	var initDone = window.autoSaveInitDone;
	if (!initDone) {
		window.autoSaveInitDone = 1;

		var ls = window.localStorage;
		if (window.localStorage && ls) {
			var storedValue = ls.getItem('autosave');

			if (storedValue) {
				var comment = document.getElementById('comment');
				if (comment) {
					comment.value += storedValue;
				}
			}
		}

		return 0;
	}

	if (document.getElementById) {
		//alert('DEBUG: DoAutoSave: document.getElementById is true');

		if (window.GetPrefs) {
			//alert('DEBUG: DoAutoSave: window.GetPrefs = TRUE');

			if (GetPrefs('write_autosave')) { // #todo this can't be right
				//alert('DEBUG: DoAutoSave: write_autosave = TRUE');

				var comment = document.getElementById('comment');
				if (comment) {
					if (window.localStorage) {
						var ls = window.localStorage;
						if (window.localStorage && ls) {
							ls.setItem('autosave', comment.value);
						}
					}
				}
			} else {
				//alert('DEBUG: write_autosave = FALSE');
			}
		} else {
			//alert('DEBUG: window.GetPrefs = FALSE');
		}
	}

	return '';
} // DoAutoSave()

function ClearAutoSave () {
	var ls = window.localStorage;
	if (window.localStorage && ls) {
		window.eventLoopDoAutoSave = 0;
		ls.removeItem('autosave');
	}
} // ClearAutoSave()

window.eventLoopDoAutoSave = 1;

// == end write.js


// == begin write_buttons.js

// if there's a user fingerprint,
// this checks for a place to put a "post as" or "reply as" button
// and if it exists, puts the button there
if (window.getUserFp) {
	if (document.getElementById && getUserFp() && document.createElement) {
		var sp = document.getElementById('signAndPost');
		var actName = 'Post as ';

		if (!sp) {
			sp = document.getElementById('replySignedContainer');
			actName = 'Sign as ';
		}

		actName = actName + getAvatar();

		if (sp) {
			var lblSignAs = document.createElement('label');
			lblSignAs.setAttribute('for', 'chkSignAs');

			var chkSignAs = document.createElement('input');
			//chkSignAs.setAttribute('name', 'signAs');
			chkSignAs.setAttribute('id', 'chkSignAs');
			chkSignAs.setAttribute('type', 'checkbox');
			chkSignAs.setAttribute('checked', 1);
			// this checkbox being checked means signMessage() is called in writeSubmit()

			lblSignAs.innerHTML = 'Sign as ' + getAvatar();

			lblSignAs.appendChild(chkSignAs);

			sp.appendChild(lblSignAs);

			////
			//	the [button] way, allowing formatting inside button
			//	if using color avatars, requiring button element instead of submit, would look like this:
			//			var btnSignReply = document.createElement('button');
			//			btnSignReply.setAttribute('onclick', "this.innerHTML = 'Meditate...'; if (window.signMessage) { signMessage(); }");
			//			btnSignReply.innerHTML = actName;

			////
			//	the <input type=submit way, more compatible
			//			var btnSignReply = document.createElement('input');
			//			btnSignReply.setAttribute('onclick', "this.value = 'Meditate...'; if (window.signMessage) { signMessage(); }");
			//			btnSignReply.setAttribute('value', actName);
			//			btnSignReply.setAttribute('type', 'submit');
			//
			//			sp.appendChild(btnSignReply);

			////
			// the old way
			//			var gt = unescape('%3E');
			// 			sp.innerHTML = '<button onclick=""' + gt + actName + getAvatar() + '</button' + gt;
		}
	}
}

// == end write_buttons.js


// == begin timestamp.js

function LongAgo (seconds) { // returns string with time units
// takes seconds as parameter
// returns a string like "3 days ago" or "3 days from now"
	var flip = 0;
	if (seconds < 0) {
		flip = 1;
		seconds = 0 - seconds;
	}

	if (seconds < 60) {
		if (seconds != 1) {
			seconds = seconds + ' seconds';
		} else {
			seconds = seconds + ' second';
		}
	} else {
		seconds = Math.floor(seconds / 60);

		if (seconds < 60) {
			if (seconds != 1) {
				seconds = seconds + ' minutes';
			} else {
				seconds = seconds + ' minute';
			}
		} else {
			seconds = Math.floor(seconds / 60);

			if (seconds < 24) {
				if (seconds != 1) {
					seconds = seconds + ' hours';
				} else {
					seconds = seconds + ' hour';
				}
			} else {
				seconds = Math.floor(seconds / 24);

				if (seconds < 7) {
					if (seconds != 1) {
						seconds = seconds + ' days';
					} else {
						seconds = seconds + ' day';
					}
				} else {
					if (seconds < 30) {
						seconds = Math.floor(seconds / 7);
						if (seconds != 1) {
							seconds = seconds + ' weeks';
						} else {
							seconds = seconds + ' week';
						}
					} else {
						if (seconds < 365) {
							seconds = Math.floor(seconds / 30);

							if (seconds != 1) {
								seconds = seconds + ' months';
							} else {
								seconds = seconds + ' month';
							}
						} else {
							seconds = Math.floor(seconds / 365);
							if (seconds != 1) {
								seconds = seconds + ' years';
							} else {
								seconds = seconds + ' year';
							}
						}
					}
				}
			}
		}
	}

	if (flip) {
		return seconds + ' ago';
	}

	if (seconds != '0 seconds') {
		return seconds + ' from now';
	}

	return 'just now!';
}

function ShowTimestamps () { // finds any class=timestamp, updates its displayed time as needed
// currently requires getElementsByClassName()
// in the future, ie4+, nn4+, and others compat can be improved

	//alert('DEBUG: ShowTimestamps()');
	if (document.getElementsByClassName) {
		//alert('DEBUG: ShowTimestamps: document.getElementsByClassName feature check passed');
		var d = new Date();
		var curTime = Math.floor(d.getTime() / 1000);
		var changeLogged = 0;
		var showAdvancedMode = 0;

		if (window.GetPrefs) {
			if (GetPrefs('expert_timestamps')) {
				showAdvancedMode = 1;
			}
		}
	
		// find elements with class=timestamp
		var te = document.getElementsByClassName("timestamp");

		//alert('DEBUG: ShowTimestamps: class=timestamp elements found: ' + te.length);
		for (var i = 0; i < te.length; i++) {
			// loop through all the timestamp elements on the page
			if (!isNaN(te[i].getAttribute('epoch'))) {
				// element also has an attribute called 'epoch', and it is
				// a number, which would represent epoch seconds
				var secs = 0 - (curTime - te[i].getAttribute('epoch')); // number of seconds since epoch begin
				var longAgo = '';
				if (!showAdvancedMode) {
					longAgo = LongAgo(secs); // what the element's displayed value should be
				} else {
					longAgo = secs;
				}

				if (te[i].innerHTML != longAgo) {
					// element's content does not already equal what it should equal
					te[i].innerHTML = longAgo;
					if ((secs * (-1)) < 3600) {
						// less than an hour ago = bold
						te[i].style.fontWeight = 'bold';
					} else {
						te[i].style.fontWeight = '';
					}
					if ((secs * (-1)) < 86400) {
						// less than a day ago = highlight
						te[i].style.backgroundColor = '#ffc080';
					} else {
						te[i].style.backgroundColor = '';
					}
					changeLogged++; // count change logged
				}
			}
		}

		if (window.EventLoop) {
			// do nothing, EventLoop() will call us when needed
			return changeLogged;
		} else {
			// allow ShowTimestamps() to run decoupled from EventLoop()
			if (changeLogged) {
				setTimeout('ShowTimestamps()', 5000);
			} else {
				setTimeout('ShowTimestamps()', 15000);
			}
			return changeLogged;
		}
	}
} // ShowTimestamps()
//
//if (window.EventLoop) {
//	// do nothing, EventLoop() will take care of us
//} else {
//	// if no EventLoop(), we do it ourselves
//	ShowTimestamps();
//}

// == end timestamp.js


// == begin fresh.js
var freshClient;
//
//function ReplacePageWithNewContent () {
//	window.location.replace(window.newPageLocation);
//	document.open();
//	document.write(window.newPageContent);
//	document.close();
//
//	return 0;
//}
//
//function StoreNewPageContent () {
//	var xmlhttp = window.xmlhttp2;
//
//	if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
//		//alert('DEBUG: PingUrlCallbackReplaceCurrentPage() found status 200');
//		window.newPageContent = xmlhttp.responseText;
//		window.newPageLocation = xmlhttp.responseURL;
//
//		//window.location.replace(xmlhttp.responseURL);
////		document.open();
////		document.write(xmlhttp.responseText);
////		document.close();
//	}
//}
//
//function FetchNewPageContent (url) {
//	if (window.XMLHttpRequest) {
//		//alert('DEBUG: PingUrl: window.XMLHttpRequest was true');
//
//		var xmlhttp;
//		if (window.xmlhttp2) {
//			xmlhttp = window.xmlhttp2;
//		} else {
//			window.xmlhttp2 = new XMLHttpRequest();
//			xmlhttp = window.xmlhttp2;
//		}
//        xmlhttp.onreadystatechange = window.StoreNewPageContent;
//        xmlhttp.open("GET", url, true);
//		xmlhttp.setRequestHeader('Cache-Control', 'no-cache');
//        xmlhttp.send();
//
//        return false;
//	}
//}


function freshCallback() { // callback for requesting HEAD for current page
//alert('DEBUG: freshCallback() this.readyState = ' + this.readyState);

//	if (1 || this.readyState == this.HEADERS_RECEIVED) { // headers received -- what we've been waiting for
	if (
		document.getElementById &&
		this.readyState == this.HEADERS_RECEIVED ||
		this.status == 200
	) { // headers received -- what we've been waiting for
		// document.title = 'DEBUG: callback received 200';
	    //alert('DEBUG: freshCallback() this.readyState == this.HEADERS_RECEIVED');

		var eTag = freshClient.getResponseHeader("ETag"); // etag header contains page 'fingerprint'

		//alert('DEBUG: eTag = ' + eTag);

		if (eTag) { // if ETag header has a value
			if (window.myOwnETag) {
				if (eTag != window.myOwnETag) {
					if (eTag == window.lastEtag) { // if it's equal to the one we saved last time
						// no new change change
					} else {
						var freshUserWantsReload = 0;  // templated
						if (freshUserWantsReload) {
							// user wants reload
							//alert('DEBUG: user wants automatic page reload');
							location.reload();
						} else {
							// user doesn't want reload, just show notification
							//alert('DEBUG: user does not want automatic page reload, notify');
							window.lastEtag = eTag;

							var ariaAlert;
							ariaAlert = document.getElementById('ariaAlert');

							if (!ariaAlert) {
								//alert('DEBUG: ariaAlert created successfully');
								ariaAlert = document.createElement('p');
								ariaAlert.setAttribute('role', 'alert');
								ariaAlert.setAttribute('id', 'ariaAlert');
								ariaAlert.style.zIndex = '1337'; //#todo

								var txtUpdated = document.createTextNode('Page updated ');
								ariaAlert.appendChild(txtUpdated);

								//document.body.appendChild(ariaAlert);
								document.body.insertBefore(ariaAlert, document.body.firstChild);
								//window.newPageContent =
								//FetchNewPageContent(window.mypath + '?' + new Date().getTime());

								//ariaAlert.innerHTML = ariaAlert.innerHTML + '+';
								var d = new Date();
								var n = d.getTime();
								n = Math.ceil(n / 1000);

								var space = document.createElement('span');
								space.innerHTML = ' ';
								ariaAlert.appendChild(space);

								var a = document.createElement('a');
								a.setAttribute('id', 'freshAria');
								a.setAttribute('href', '#');
								a.setAttribute('onclick', 'location.reload()');
								ariaAlert.appendChild(a);

								var newTs = document.createElement('span');
								newTs.setAttribute('class', 'timestamp');
								newTs.setAttribute('epoch', n);
								newTs.setAttribute('id', 'freshTimestamp');
								newTs.innerHTML = 'just now!';
								a.appendChild(newTs);
							} // !ariaAlert

							if (window.freshTimeoutId) {
								clearTimeout(window.freshTimeoutId);
							}
							//window.eventLoopFresh = 0; // stop checking for updates

							if (document.title.substring(0, 2) != '! ') {
								document.title = '! ' + document.title;
							}
						} // NOT freshUserWantsReload
					} // lastEtag also didn't match
				} // eTag != window.myOwnETag
				else {
					//document.title = 'freshCallback: x ' + window.myOwnETag + ';' + new Date().getTime();
					if (window.freshTimeoutId) {
						clearTimeout(window.freshTimeoutId);
					}
					window.freshTimeoutId = setTimeout('CheckIfFresh()', 15000);
				}
			} // if (window.myOwnETag)
			else {
				window.myOwnETag = eTag;
			}
		} // if (eTag) // ETag header has value
	} // status == 200
	if (this.status == 404 && document.getElementById) {
		//alert('DEBUG: page has gone away on server (404)');
		var ariaAlert;
		ariaAlert = document.getElementById('ariaAlert');
		if (!ariaAlert) {
			ariaAlert = document.createElement('p');
			ariaAlert.setAttribute('role', 'alert');
			ariaAlert.setAttribute('id', 'ariaAlert');
			ariaAlert.style.zIndex = '1337'; //#todo
			ariaAlert.innerHTML = 'Page deleted';

			//document.body.appendChild(ariaAlert);
			document.body.insertBefore(ariaAlert, document.body.firstChild);
		}
		// window.eventLoopFresh = 0; // stop checking for updates
	} // status == 404

	return true;
} //freshCallback()

function CheckIfFresh () {
	var d = new Date();
	//alert('debug: CheckIfFresh: ' + d.getTime());

	var freshCheckRecent = window.freshCheckRecent;
	if (freshCheckRecent) {
		//alert('debug: CheckIfFresh: freshCheckRecent = ' + freshCheckRecent);
		var d = new Date();
		var curTime = d.getTime();
		if (curTime < freshCheckRecent + 3000) {
			return true;
		}
	}
	//alert('debug: CheckIfFresh: checkpoint passed');

	var d = new Date();
	window.freshCheckRecent = d.getTime();

	var xhr = null;
	if (window.XMLHttpRequest){
    	xhr = new XMLHttpRequest();
    }
    else {
    	if (window.ActiveXObject) {
    		xhr = new ActiveXObject("Microsoft.XMLHTTP");
		}
    }

	if (xhr) {
		var mypath = window.mypath;

		if (!mypath) {
			mypath = window.location;
			window.mypath = mypath;
		}

		freshClient = xhr;

		if (0 && mypath.toString().indexOf('?') == -1) {
			// this ensures no caching, but may cause other problems
			freshClient.open("HEAD", mypath + '?' + d.getTime(), true);
		} else {
			freshClient.open("HEAD", mypath, true);
		}

    	//freshClient.timeout = 5000; //#xhr.timeout
		freshClient.setRequestHeader('Cache-Control', 'no-cache');
		freshClient.onreadystatechange = freshCallback;

		freshClient.send();
	}

	return true;
} // CheckIfFresh()
//
//if (window.GetPrefs) {
//	var needNotify = (GetPrefs('notify_on_change') ? 1 : 0);
//	if (needNotify == 1) { // check value of notify_on_change preference
//		if (window.EventLoop) {
//			EventLoop();
//		} else {
//			CheckIfFresh();
//		}
//	}
//}

//alert('DEBUG: fresh.js');

// == end fresh.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->
</body></html>
<!-- InjectJs2: back_to_top_button -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin back_to_top_button.js
function showBackToTop () { // show or hide "back to top" button depending on vertical scroll state
    var pageOffset = document.body.scrollTop;

    if (100 < pageOffset) {
    	if (window.showBackToTopLastAction != 1) {
//			var colorBody = document.body.style.backgroundColor || document.body.getAttribute('bgcolor'));
//			var colorButton = document.getElementById('aBackToTop').style.backgroundColor;
//
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#002000'", 250);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#004000'", 500);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#006000'", 750);
//			setTimeout("document.getElementById('aBackToTop').style.backgroundColor = '#008000'", 1000);

			document.getElementById('aBackToTop').style.visibility = 'visible';
			window.showBackToTopLastAction = 1;
		}
    } else {
    	if (window.showBackToTopLastAction != 0) {
        	document.getElementById('aBackToTop').style.visibility = 'hidden';
        	window.showBackToTopLastAction = 0;
		}
    }

    return true;
} // showBackToTop()

if (document.getElementById) { // enable window.onscroll if getElementById exists
    window.onscroll = window.showBackToTop;
    showBackToTop();
}
// end back_to_top_button.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->

<!-- InjectJs2: loading_end -->

<!-- html/utils/scriptinject.template -->
<script language=javascript><!--
// begin loading_end.js

function HideLoadingIndicator () {
	if (!document.getElementById) {
		return '';
	}

	var loadingIndicator = window.loadingIndicator;

	if (!loadingIndicator) {
		if (document.getElementById) {
			loadingIndicator = document.getElementById('loadingIndicator');
		}
	}

	if (window.loadingIndicatorShowTimeout) {
		clearTimeout(loadingIndicatorShowTimeout);
	}

	loadingIndicator.innerHTML = 'Ready.';
//	loadingIndicator.style.backgroundColor = '$colorHighlightAdvanced';

	window.loadingIndicator = loadingIndicator;

	setTimeout('if (window.loadingIndicator) { window.loadingIndicator.style.display = "none"; }', 3000); //#todo
	// } else {
	// 	if (loadingIndicator) { loadingIndicator.style.display = 'none' }
	// }
	return '';
} // HideLoadingIndicator()

function WaitForOpenPgp () {
	//alert('debug: WaitForOpenPgp()');
	var d = new Date();
	if (window.openPgpJsLoadBegin && window.openpgp) {
		HideLoadingIndicator();
	} else {
		setTimeout('if (window.WaitForOpenPgp) { WaitForOpenPgp() }', 500);
	}
} // WaitForOpenPgp()

if (!window.OnLoadEverything && window.HideLoadingIndicator) {
	HideLoadingIndicator();
}

// end loading_end.js

// -->
</script>
<!-- / html/utils/scriptinject.template -->
